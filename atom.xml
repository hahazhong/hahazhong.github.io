<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HaHazhong&amp;Blog</title>
  
  <subtitle>人生苦短，我用Python</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-17T14:19:45.583Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>hahazhong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python进阶（十一）-- NumPy模块</title>
    <link href="http://example.com/2022/11/17/Python%E8%BF%9B%E9%98%B6(%E5%8D%81%E4%B8%80)Numpy%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2022/11/17/Python%E8%BF%9B%E9%98%B6(%E5%8D%81%E4%B8%80)Numpy%E6%A8%A1%E5%9D%97/</id>
    <published>2022-11-17T12:23:31.000Z</published>
    <updated>2022-11-17T14:19:45.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy模块"><a href="#NumPy模块" class="headerlink" title="NumPy模块"></a>NumPy模块</h1><p>NumPy是用于数据科学计算的基础模块,不但能够完成科学计算的任务,而且能被用于高效得多维数组容器,可用于存储和处理大型矩阵。</p><span id="more"></span>  <h2 id="ndarray数组"><a href="#ndarray数组" class="headerlink" title="ndarray数组"></a>ndarray数组</h2><p>NumPy库的核心特征之一就是ndaaray对象，它为Python提供了真正的多维数组功能，该对象是一个快速而灵活的大数据集容器。</p><h3 id="ndarray数组创建"><a href="#ndarray数组创建" class="headerlink" title="ndarray数组创建"></a>ndarray数组创建</h3><ol><li><p>array(序列)</p><p>将序列转化为ndarray数组</p></li><li><p>zeros()函数</p><p>创建指定长度或形状全为0的数组</p></li><li><p>ones()函数</p><p>创建指定长度或形状的全1数组</p></li><li><p>empty()函数</p><p>创建一个没有具体数值的数组(即垃圾值)</p></li><li><p>arange()函数</p><p>类似于Python的range()函数,但是arange()函数主要创建数组</p></li></ol><h3 id="ndarray对象的属性"><a href="#ndarray对象的属性" class="headerlink" title="ndarray对象的属性"></a>ndarray对象的属性</h3><table><thead><tr><th>属性</th><th>使用说明</th></tr></thead><tbody><tr><td>.ndim</td><td>数组的维度</td></tr><tr><td>.shape</td><td>数组的尺寸,对于n行m列的矩阵,形状为(n,m)</td></tr><tr><td>.size</td><td>数组元素的总个数</td></tr><tr><td>.dtype</td><td>数组元素的类型</td></tr><tr><td>.itemsize</td><td>数组中每个元素的字节大小</td></tr></tbody></table><h3 id="ndarray数据类型"><a href="#ndarray数据类型" class="headerlink" title="ndarray数据类型"></a>ndarray数据类型</h3><p>数组中的数据类型有多中,最常见的为浮点数(float)、整数(int)、复数(complex)、布尔值(bool)、字符串(string_)、Python对象(object)。</p><p>对于创建好的ndarray,可通过astype函数进行数据类型转换.</p><h3 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h3><h4 id="变换数组形态"><a href="#变换数组形态" class="headerlink" title="变换数组形态"></a>变换数组形态</h4><p>对于数组进行操作,经常要改变数组维度。在NumPy中，常用reshape()函数改变数组维度.其参数为一个正整数元组,分别制定数组在每个维度的大小,reshape()函数在改变原始数据形状的同时不改变原始数据的值.</p><p>与reshape相反的方法是数据散开(ravel())或则数据扁平化flatten()</p><h4 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h4><p>使用<code>concatenate()</code>函数,通过指定轴方向,将多个数组和并在一起</p><h4 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h4><p>数组拆分是数组合并的相反操作,通过split()函数、vsplit()函数和hsplit()函数可以将数组分为多个数组。</p><h4 id="数组转置"><a href="#数组转置" class="headerlink" title="数组转置"></a>数组转置</h4><p>数组转置可以使用transpose()函数.transpose()函数需要传入轴编号组成的元组,这样就完成了数组的转置.除了使用transpose()函数外,数组的T属性,也可以用于数组的转置.</p><h3 id="NumPy的随机数函数"><a href="#NumPy的随机数函数" class="headerlink" title="NumPy的随机数函数"></a>NumPy的随机数函数</h3><p>NumPy提供了强大的生成随机数的功能.在numpy.random模块中有多种随机数生成函数.例如:</p><table><thead><tr><th>函数</th><th>使用说明</th></tr></thead><tbody><tr><td>rand</td><td>产生均匀分布的样本值</td></tr><tr><td>randint</td><td>给定范围内取随机整数</td></tr><tr><td>randn</td><td>产生正态分布的样本值</td></tr><tr><td>seed</td><td>随机数种子</td></tr><tr><td>permutation</td><td>对一个序列随机排序,不改变原数组</td></tr><tr><td>shuffle</td><td>对一个序列随机排序,改变数组</td></tr><tr><td>uniform(low,high,size)</td><td>产生均匀分布的数组,low表示起始值,high表示结束值,size表示形状</td></tr><tr><td>normal(loc,scale,size)</td><td>产生具有正态分布的数组,loc表示均值,scale表示标准差,size表示形状</td></tr></tbody></table><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p>NumPy专门为科学计算而生,数组支持所有常规的算术运算,NumPy库中包含完整的基本数学函数,这些函数在数组运算上发挥了很大的作用.</p><h3 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>abs()</td><td>求绝对值</td></tr><tr><td>square()</td><td>求平方</td></tr><tr><td>add()</td><td>两个数组的相加</td></tr><tr><td>minimum()</td><td>计算元素最小值</td></tr></tbody></table><p>更多通用函数用法可以去NumPy官网查看</p><p>另外Scipy还在scipy.special中提供了一个丰富的特殊函数库,具有贝塞尔、艾里、菲涅尔等古典特殊函数。</p><h3 id="条件逻辑运算"><a href="#条件逻辑运算" class="headerlink" title="条件逻辑运算"></a>条件逻辑运算</h3><p>where()函数可以通过一些条件对数组进行处理,语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where(cond,arr1,arr2)</span><br></pre></td></tr></table></figure><p>就是通过cond的值来选择arr1或则arr2的值</p><p>如果需要进行多条件判别,也可以通过嵌套where表达式完成</p><p>这种方法通过if判断可以实现,但是where()函数的优点:</p><ul><li>对大规模数组处理速度快</li><li>可以用于多维数组</li></ul><h3 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a>统计运算</h3><table><thead><tr><th>函数</th><th>使用说明</th></tr></thead><tbody><tr><td>sum</td><td>求和</td></tr><tr><td>mean</td><td>算术平均数</td></tr><tr><td>std、var</td><td>标准差和方差</td></tr><tr><td>min、max</td><td>最小值和最大值</td></tr><tr><td>argmin、argmax</td><td>最小和最大元素索引</td></tr><tr><td>cumsum</td><td>所有元素的累计和</td></tr><tr><td>cumprod</td><td>所有元素的累计和</td></tr><tr><td>sort()</td><td>排序</td></tr></tbody></table><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><ol><li><p>unique()函数寻找数组中的唯一值</p><p>对唯一值会进行排序</p></li><li><p>inld()用于测试几个数组中是否包含相同的值,返回一个布尔值数组</p></li></ol><table><thead><tr><th>函数</th><th>使用说明</th></tr></thead><tbody><tr><td>unique(x)</td><td>唯一值</td></tr><tr><td>intersectld(x,y)</td><td>公共元素</td></tr><tr><td>unionld(x,y)</td><td>并集</td></tr><tr><td>inld(x,y)</td><td>x的元素是否在y中,返回布尔型数组</td></tr><tr><td>setdiffld(x,y)</td><td>集合的差</td></tr><tr><td>setxorld(x,y)</td><td>交集取反</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;NumPy模块&quot;&gt;&lt;a href=&quot;#NumPy模块&quot; class=&quot;headerlink&quot; title=&quot;NumPy模块&quot;&gt;&lt;/a&gt;NumPy模块&lt;/h1&gt;&lt;p&gt;NumPy是用于数据科学计算的基础模块,不但能够完成科学计算的任务,而且能被用于高效得多维数组容器,可用于存储和处理大型矩阵。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="NumPy模块" scheme="http://example.com/tags/NumPy%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（十）-- 网络爬虫</title>
    <link href="http://example.com/2022/11/14/Python%E8%BF%9B%E9%98%B6(%E5%8D%81)%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <id>http://example.com/2022/11/14/Python%E8%BF%9B%E9%98%B6(%E5%8D%81)%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</id>
    <published>2022-11-14T13:23:31.000Z</published>
    <updated>2022-11-17T13:44:41.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用Python获取网络数据"><a href="#用Python获取网络数据" class="headerlink" title="用Python获取网络数据"></a>用Python获取网络数据</h1><p>网络数据采集是 Python 语言非常擅长的领域，上节课我们讲到，实现网络数据采集的程序通常称之为网络爬虫或蜘蛛程序。即便是在大数据时代，数据对于中小企业来说仍然是硬伤和短板，有些数据需要通过开放或付费的数据接口来获得，其他的行业数据和竞对数据则必须要通过网络数据采集的方式来获得。不管使用哪种方式获取网络数据资源，Python 语言都是非常好的选择，因为 Python 的标准库和三方库都对网络数据采集提供了良好的支持。</p><span id="more"></span>  <h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><p>要使用 Python 获取网络数据，我们推荐大家使用名为<code>requests</code> 的三方库，这个库我们在之前的课程中其实已经使用过了。按照官方网站的解释，<code>requests</code>是基于 Python 标准库进行了封装，简化了通过 HTTP 或 HTTPS 访问网络资源的操作。上课我们提到过，HTTP 是一个请求响应式的协议，当我们在浏览器中输入正确的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL">URL</a>（通常也称为网址）并按下 Enter 键时，我们就向网络上的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_web_server">Web 服务器</a>发送了一个 HTTP 请求，服务器在收到请求后会给我们一个 HTTP 响应。在 Chrome 浏览器中的菜单中打开“开发者工具”切换到“Network”选项卡就能够查看 HTTP 请求和响应到底是什么样子的，如下图所示。</p><p>通过<code>requests</code>库，我们可以让 Python 程序向浏览器一样向 Web 服务器发起请求，并接收服务器返回的响应，从响应中我们就可以提取出想要的数据。浏览器呈现给我们的网页是用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML</a> 编写的，浏览器相当于是 HTML 的解释器环境，我们看到的网页中的内容都包含在 HTML 的标签中。在获取到 HTML 代码后，就可以从标签的属性或标签体中提取内容。下面例子演示了如何获取网页 HTML 代码，我们通过<code>requests</code>库的<code>get</code>函数，获取了搜狐首页的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.get(<span class="string">&#x27;https://www.sohu.com/&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面代码中的变量<code>resp</code>是一个<code>Response</code>对象（<code>requests</code>库封装的类型），通过该对象的<code>status_code</code>属性可以获取响应状态码，而该对象的<code>text</code>属性可以帮我们获取到页面的 HTML 代码。</p></blockquote><p>由于<code>Response</code>对象的<code>text</code>是一个字符串，所以我们可以利用之前讲过的正则表达式的知识，从页面的 HTML 代码中提取新闻的标题和链接，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a.*?href=&quot;(.*?)&quot;.*?title=&quot;(.*?)&quot;.*?&gt;&#x27;</span>)</span><br><span class="line">resp = requests.get(<span class="string">&#x27;https://www.sohu.com/&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">    all_matches = pattern.findall(resp.text)</span><br><span class="line">    <span class="keyword">for</span> href, title <span class="keyword">in</span> all_matches:</span><br><span class="line">        <span class="built_in">print</span>(href)</span><br><span class="line">        <span class="built_in">print</span>(title)</span><br></pre></td></tr></table></figure><p>除了文本内容，我们也可以使用<code>requests</code>库通过 URL 获取二进制资源。下面的例子演示了如何获取百度 Logo 并保存到名为<code>baidu.png</code>的本地文件中。可以在百度的首页上右键点击百度Logo，并通过“复制图片地址”菜单项获取图片的 URL。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.get(<span class="string">&#x27;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;baidu.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(resp.content)</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：<code>Response</code>对象的<code>content</code>属性可以获得服务器响应的二进制数据。</p></blockquote><p><code>requests</code>库非常好用而且功能上也比较强大和完整，具体的内容我们在使用的过程中为大家一点点剖析。想解锁关于<code>requests</code>库更多的知识，可以阅读它的<a href="https://docs.python-requests.org/zh_CN/latest/">官方文档</a>。</p><h2 id="编写爬虫代码"><a href="#编写爬虫代码" class="headerlink" title="编写爬虫代码"></a>编写爬虫代码</h2><p>接下来，我们以“豆瓣电影”为例，为大家讲解如何编写爬虫代码。按照上面提供的方法，我们先使用<code>requests</code>获取到网页的HTML代码，然后将整个代码看成一个长字符串，这样我们就可以使用正则表达式的捕获组从字符串提取我们需要的内容。下面的代码演示了如何从<a href="https://movie.douban.com/">豆瓣电影</a>获取排前250名的电影的名称。<a href="https://movie.douban.com/top250">豆瓣电影Top250</a>的页面结构和对应代码如下图所示，可以看出，每页共展示了25部电影，如果要获取到 Top250 数据，我们共需要访问10个页面，对应的地址是<a href="https://movie.douban.com/top250?start=xxx">https://movie.douban.com/top250?start=xxx</a>，这里的<code>xxx</code>如果为<code>0</code>就是第一页，如果<code>xxx</code>的值是<code>100</code>，那么我们可以访问到第五页。为了代码简单易读，我们只获取电影的标题和评分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    resp = requests.get(</span><br><span class="line">        url=<span class="string">f&#x27;https://movie.douban.com/top250?start=<span class="subst">&#123;(page - <span class="number">1</span>) * <span class="number">25</span>&#125;</span>&#x27;</span>,</span><br><span class="line">        <span class="comment"># 如果不设置HTTP请求头中的User-Agent，豆瓣会检测出不是浏览器而阻止我们的请求。</span></span><br><span class="line">        <span class="comment"># 通过get函数的headers参数设置User-Agent的值，具体的值可以在浏览器的开发者工具查看到。</span></span><br><span class="line">        <span class="comment"># 用爬虫访问大部分网站时，将爬虫伪装成来自浏览器的请求都是非常重要的一步。</span></span><br><span class="line">        headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 通过正则表达式获取class属性为title且标签体不以&amp;开头的span标签并用捕获组提取标签内容</span></span><br><span class="line">    pattern1 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span class=&quot;title&quot;&gt;([^&amp;]*?)&lt;/span&gt;&#x27;</span>)</span><br><span class="line">    titles = pattern1.findall(resp.text)</span><br><span class="line">    <span class="comment"># 通过正则表达式获取class属性为rating_num的span标签并用捕获组提取标签内容</span></span><br><span class="line">    pattern2 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span class=&quot;rating_num&quot;.*?&gt;(.*?)&lt;/span&gt;&#x27;</span>)</span><br><span class="line">    ranks = pattern2.findall(resp.text)</span><br><span class="line">    <span class="comment"># 使用zip压缩两个列表，循环遍历所有的电影标题和评分</span></span><br><span class="line">    <span class="keyword">for</span> title, rank <span class="keyword">in</span> <span class="built_in">zip</span>(titles, ranks):</span><br><span class="line">        <span class="built_in">print</span>(title, rank)</span><br><span class="line">    <span class="comment"># 随机休眠1-5秒，避免爬取页面过于频繁</span></span><br><span class="line">    time.sleep(random.random() * <span class="number">4</span> + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：通过分析豆瓣网的robots协议，我们发现豆瓣网并不拒绝百度爬虫获取它的数据，因此我们也可以将爬虫伪装成百度的爬虫，将<code>get</code>函数的<code>headers</code>参数修改为：<code>headers=&#123;&#39;User-Agent&#39;: &#39;BaiduSpider&#39;&#125;</code>。</p></blockquote><h2 id="使用-IP-代理"><a href="#使用-IP-代理" class="headerlink" title="使用 IP 代理"></a>使用 IP 代理</h2><p>让爬虫程序隐匿自己的身份对编写爬虫程序来说是比较重要的，很多网站对爬虫都比较反感的，因为爬虫会耗费掉它们很多的网络带宽并制造很多无效的流量。要隐匿身份通常需要使用<strong>商业 IP 代理</strong>（如蘑菇代理、芝麻代理、快代理等），让被爬取的网站无法获取爬虫程序来源的真实 IP 地址，也就无法简单的通过 IP 地址对爬虫程序进行封禁。</p><p>下面以<a href="http://www.moguproxy.com/">蘑菇代理</a>为例，为大家讲解商业 IP 代理的使用方法。首先需要在该网站注册一个账号，注册账号后就可以<a href="http://www.moguproxy.com/buy">购买</a>相应的套餐来获得商业 IP 代理。作为商业用途，建议大家购买不限量套餐，这样可以根据实际需要获取足够多的代理 IP 地址；作为学习用途，可以购买包时套餐或根据自己的需求来决定。蘑菇代理提供了两种接入代理的方式，分别是 API 私密代理和 HTTP 隧道代理，前者是通过请求蘑菇代理的 API 接口获取代理服务器地址，后者是直接使用统一的入口（蘑菇代理提供的域名）进行接入。</p><p>下面，我们以HTTP隧道代理为例，为大家讲解接入 IP 代理的方式，大家也可以直接参考蘑菇代理官网提供的代码来为爬虫设置代理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">APP_KEY = <span class="string">&#x27;Wnp******************************XFx&#x27;</span></span><br><span class="line">PROXY_HOST = <span class="string">&#x27;secondtransfer.moguproxy.com:9001&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    resp = requests.get(</span><br><span class="line">        url=<span class="string">f&#x27;https://movie.douban.com/top250?start=<span class="subst">&#123;(page - <span class="number">1</span>) * <span class="number">25</span>&#125;</span>&#x27;</span>,</span><br><span class="line">        <span class="comment"># 需要在HTTP请求头设置代理的身份认证方式</span></span><br><span class="line">        headers=&#123;</span><br><span class="line">            <span class="string">&#x27;Proxy-Authorization&#x27;</span>: <span class="string">f&#x27;Basic <span class="subst">&#123;APP_KEY&#125;</span>&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 设置代理服务器</span></span><br><span class="line">        proxies=&#123;</span><br><span class="line">            <span class="string">&#x27;http&#x27;</span>: <span class="string">f&#x27;http://<span class="subst">&#123;PROXY_HOST&#125;</span>&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https&#x27;</span>: <span class="string">f&#x27;https://<span class="subst">&#123;PROXY_HOST&#125;</span>&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        verify=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line">    pattern1 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span class=&quot;title&quot;&gt;([^&amp;]*?)&lt;/span&gt;&#x27;</span>)</span><br><span class="line">    titles = pattern1.findall(resp.text)</span><br><span class="line">    pattern2 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span class=&quot;rating_num&quot;.*?&gt;(.*?)&lt;/span&gt;&#x27;</span>)</span><br><span class="line">    ranks = pattern2.findall(resp.text)</span><br><span class="line">    <span class="keyword">for</span> title, rank <span class="keyword">in</span> <span class="built_in">zip</span>(titles, ranks):</span><br><span class="line">        <span class="built_in">print</span>(title, rank)</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面的代码需要修改<code>APP_KEY</code>为自己创建的订单对应的<code>Appkey</code>值，这个值可以在用户中心用户订单中查看到。蘑菇代理提供了免费的 API 代理和 HTTP 隧道代理试用，但是试用的代理接通率不能保证，建议大家还是直接购买一个在自己支付能力范围内的代理服务来体验。</p><p><strong>另注</strong>：蘑菇代理目前已经停止服务了，大家可以按照上面讲解的方式使用其他商业代理即可。</p></blockquote><h1 id="用Python解析HTML页面"><a href="#用Python解析HTML页面" class="headerlink" title="用Python解析HTML页面"></a>用Python解析HTML页面</h1><p>在前面的课程中，我们讲到了使用<code>request</code>三方库获取网络资源，还介绍了一些前端的基础知识。接下来，我们继续探索如何解析 HTML 代码，从页面中提取出有用的信息。之前，我们尝试过用正则表达式的捕获组操作提取页面内容，但是写出一个正确的正则表达式也是一件让人头疼的事情。为了解决这个问题，我们得先深入的了解一下 HTML 页面的结构，并在此基础上研究另外的解析页面的方法。</p><h2 id="HTML-页面的结构"><a href="#HTML-页面的结构" class="headerlink" title="HTML 页面的结构"></a>HTML 页面的结构</h2><p>我们在浏览器中打开任意一个网站，然后通过鼠标右键菜单，选择“显示网页源代码”菜单项，就可以看到网页对应的 HTML 代码。</p><p>代码的第<code>1</code>行是文档类型声明，第<code>2</code>行的<code>&lt;html&gt;</code>标签是整个页面根标签的开始标签，最后一行是根标签的结束标签<code>&lt;/html&gt;</code>。<code>&lt;html&gt;</code>标签下面有两个子标签<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>，放在<code>&lt;body&gt;</code>标签下的内容会显示在浏览器窗口中，这部分内容是网页的主体；放在<code>&lt;head&gt;</code>标签下的内容不会显示在浏览器窗口中，但是却包含了页面重要的元信息，通常称之为网页的头部。HTML 页面大致的代码结构如下所示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 页面的元信息，如字符编码、标题、关键字、媒体查询等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 页面的主体，显示在浏览器窗口中的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签、层叠样式表（CSS）、JavaScript 是构成 HTML 页面的三要素，其中标签用来承载页面要显示的内容，CSS 负责对页面的渲染，而 JavaScript 用来控制页面的交互式行为。要实现 HTML 页面的解析，可以使用 XPath 的语法，它原本是 XML 的一种查询语法，可以根据 HTML 标签的层次结构提取标签中的内容或标签属性；此外，也可以使用 CSS 选择器来定位页面元素，就跟用 CSS 渲染页面元素是同样的道理。</p><h2 id="XPath-解析"><a href="#XPath-解析" class="headerlink" title="XPath 解析"></a>XPath 解析</h2><p>XPath 是在 XML（eXtensible Markup Language）文档中查找信息的一种语法，XML 跟 HTML 类似也是一种用标签承载数据的标签语言，不同之处在于 XML 的标签是可扩展的，可以自定义的，而且 XML 对语法有更严格的要求。XPath 使用路径表达式来选取 XML 文档中的节点或者节点集，这里所说的节点包括元素、属性、文本、命名空间、处理指令、注释、根节点等。下面我们通过一个例子来说明如何使用 XPath 对页面进行解析。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上面的 XML 文件，我们可以用如下所示的 XPath 语法获取文档中的节点。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>/bookstore</code></td><td>选取根元素 bookstore。<strong>注意</strong>：假如路径起始于正斜杠( &#x2F; )，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td><code>//book</code></td><td>选取所有 book 子元素，而不管它们在文档中的位置。</td></tr><tr><td><code>//@lang</code></td><td>选取名为 lang 的所有属性。</td></tr><tr><td><code>/bookstore/book[1]</code></td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td><code>/bookstore/book[last()]</code></td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td><code>/bookstore/book[last()-1]</code></td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td><code>/bookstore/book[position()&lt;3]</code></td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td><code>//title[@lang]</code></td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td><code>//title[@lang=&#39;eng&#39;]</code></td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td><code>/bookstore/book[price&gt;35.00]</code></td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td><code>/bookstore/book[price&gt;35.00]/title</code></td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table><p>XPath还支持通配符用法，如下所示。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>/bookstore/*</code></td><td>选取 bookstore 元素的所有子元素。</td></tr><tr><td><code>//*</code></td><td>选取文档中的所有元素。</td></tr><tr><td><code>//title[@*]</code></td><td>选取所有带有属性的 title 元素。</td></tr></tbody></table><p>如果要选取多个节点，可以使用如下所示的方法。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>//book/title | //book/price</code></td><td>选取 book 元素的所有 title 和 price 元素。</td></tr><tr><td><code>//title | //price</code></td><td>选取文档中的所有 title 和 price 元素。</td></tr><tr><td><code>/bookstore/book/title | //price</code></td><td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td></tr></tbody></table><blockquote><p><strong>说明</strong>：上面的例子来自于“菜鸟教程”网站上的 <a href="https://www.runoob.com/xpath/xpath-tutorial.html">XPath 教程</a>，有兴趣的读者可以自行阅读原文。</p></blockquote><p>当然，如果不理解或不熟悉 XPath 语法，可以在浏览器的开发者工具中按照如下所示的方法查看元素的 XPath 语法</p><p>实现 XPath 解析需要三方库<code>lxml</code> 的支持，可以使用下面的命令安装<code>lxml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><p>下面我们用 XPath 解析方式改写之前获取豆瓣电影 Top250的代码，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    resp = requests.get(</span><br><span class="line">        url=<span class="string">f&#x27;https://movie.douban.com/top250?start=<span class="subst">&#123;(page - <span class="number">1</span>) * <span class="number">25</span>&#125;</span>&#x27;</span>,</span><br><span class="line">        headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;BaiduSpider&#x27;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    tree = etree.HTML(resp.text)</span><br><span class="line">    <span class="comment"># 通过XPath语法从页面中提取电影标题</span></span><br><span class="line">    title_spans = tree.xpath(<span class="string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/ol/li/div/div[2]/div[1]/a/span[1]&#x27;</span>)</span><br><span class="line">    <span class="comment"># 通过XPath语法从页面中提取电影评分</span></span><br><span class="line">    rank_spans = tree.xpath(<span class="string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[2]/div/span[2]&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> title_span, rank_span <span class="keyword">in</span> <span class="built_in">zip</span>(title_spans, rank_spans):</span><br><span class="line">        <span class="built_in">print</span>(title_span.text, rank_span.text)</span><br></pre></td></tr></table></figure><h2 id="CSS-选择器解析"><a href="#CSS-选择器解析" class="headerlink" title="CSS 选择器解析"></a>CSS 选择器解析</h2><p>对于熟悉 CSS 选择器和 JavaScript 的开发者来说，通过 CSS 选择器获取页面元素可能是更为简单的选择，因为浏览器中运行的 JavaScript 本身就可以<code>document</code>对象的<code>querySelector()</code>和<code>querySelectorAll()</code>方法基于 CSS 选择器获取页面元素。在 Python 中，我们可以利用三方库<code>beautifulsoup4</code>或<code>pyquery</code>来做同样的事情。Beautiful Soup 可以用来解析 HTML 和 XML 文档，修复含有未闭合标签等错误的文档，通过为待解析的页面在内存中创建一棵树结构，实现对从页面中提取数据操作的封装。可以用下面的命令来安装 Beautiful Soup。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><p>下面是使用<code>bs4</code>改写的获取豆瓣电影Top250电影名称的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    resp = requests.get(</span><br><span class="line">        url=<span class="string">f&#x27;https://movie.douban.com/top250?start=<span class="subst">&#123;(page - <span class="number">1</span>) * <span class="number">25</span>&#125;</span>&#x27;</span>,</span><br><span class="line">        headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;BaiduSpider&#x27;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 创建BeautifulSoup对象</span></span><br><span class="line">    soup = bs4.BeautifulSoup(resp.text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="comment"># 通过CSS选择器从页面中提取包含电影标题的span标签</span></span><br><span class="line">    title_spans = soup.select(<span class="string">&#x27;div.info &gt; div.hd &gt; a &gt; span:nth-child(1)&#x27;</span>)</span><br><span class="line">    <span class="comment"># 通过CSS选择器从页面中提取包含电影评分的span标签</span></span><br><span class="line">    rank_spans = soup.select(<span class="string">&#x27;div.info &gt; div.bd &gt; div &gt; span.rating_num&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> title_span, rank_span <span class="keyword">in</span> <span class="built_in">zip</span>(title_spans, rank_spans):</span><br><span class="line">        <span class="built_in">print</span>(title_span.text, rank_span.text)</span><br></pre></td></tr></table></figure><p>关于 BeautifulSoup 更多的知识，可以参考它的<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">官方文档</a>。</p><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>下面我们对三种解析方式做一个简单比较。</p><table><thead><tr><th>解析方式</th><th>对应的模块</th><th>速度</th><th>使用难度</th></tr></thead><tbody><tr><td>正则表达式解析</td><td><code>re</code></td><td>快</td><td>困难</td></tr><tr><td>XPath 解析</td><td><code>lxml</code></td><td>快</td><td>一般</td></tr><tr><td>CSS 选择器解析</td><td><code>bs4</code>或<code>pyquery</code></td><td>不确定</td><td>简单</td></tr></tbody></table><h1 id="爬虫框架Scrapy简介"><a href="#爬虫框架Scrapy简介" class="headerlink" title="爬虫框架Scrapy简介"></a>爬虫框架Scrapy简介</h1><p>当你写了很多个爬虫程序之后，你会发现每次写爬虫程序时，都需要将页面获取、页面解析、爬虫调度、异常处理、反爬应对这些代码从头至尾实现一遍，这里面有很多工作其实都是简单乏味的重复劳动。那么，有没有什么办法可以提升我们编写爬虫代码的效率呢？答案是肯定的，那就是利用爬虫框架，而在所有的爬虫框架中，Scrapy 应该是最流行、最强大的框架。</p><h2 id="Scrapy-概述"><a href="#Scrapy-概述" class="headerlink" title="Scrapy 概述"></a>Scrapy 概述</h2><p>Scrapy 是基于 Python 的一个非常流行的网络爬虫框架，可以用来抓取 Web 站点并从页面中提取结构化的数据。</p><h3 id="Scrapy的组件"><a href="#Scrapy的组件" class="headerlink" title="Scrapy的组件"></a>Scrapy的组件</h3><p>我们先来说说 Scrapy 中的组件。</p><ol><li>Scrapy 引擎（Engine）：用来控制整个系统的数据处理流程。</li><li>调度器（Scheduler）：调度器从引擎接受请求并排序列入队列，并在引擎发出请求后返还给它们。</li><li>下载器（Downloader）：下载器的主要职责是抓取网页并将网页内容返还给蜘蛛（Spiders）。</li><li>蜘蛛程序（Spiders）：蜘蛛是用户自定义的用来解析网页并抓取特定URL的类，每个蜘蛛都能处理一个域名或一组域名，简单的说就是用来定义特定网站的抓取和解析规则的模块。</li><li>数据管道（Item Pipeline）：管道的主要责任是负责处理有蜘蛛从网页中抽取的数据条目，它的主要任务是清理、验证和存储数据。当页面被蜘蛛解析后，将被发送到数据管道，并经过几个特定的次序处理数据。每个数据管道组件都是一个 Python 类，它们获取了数据条目并执行对数据条目进行处理的方法，同时还需要确定是否需要在数据管道中继续执行下一步或是直接丢弃掉不处理。数据管道通常执行的任务有：清理 HTML 数据、验证解析到的数据（检查条目是否包含必要的字段）、检查是不是重复数据（如果重复就丢弃）、将解析到的数据存储到数据库（关系型数据库或 NoSQL 数据库）中。</li><li>中间件（Middlewares）：中间件是介于引擎和其他组件之间的一个钩子框架，主要是为了提供自定义的代码来拓展 Scrapy 的功能，包括下载器中间件和蜘蛛中间件。</li></ol><h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p>Scrapy 的整个数据处理流程由引擎进行控制，通常的运转流程包括以下的步骤：</p><ol><li><p>引擎询问蜘蛛需要处理哪个网站，并让蜘蛛将第一个需要处理的 URL 交给它。</p></li><li><p>引擎让调度器将需要处理的 URL 放在队列中。</p></li><li><p>引擎从调度那获取接下来进行爬取的页面。</p></li><li><p>调度将下一个爬取的 URL 返回给引擎，引擎将它通过下载中间件发送到下载器。</p></li><li><p>当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎；如果下载失败了，引擎会通知调度器记录这个 URL，待会再重新下载。</p></li><li><p>引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。</p></li><li><p>蜘蛛处理响应并返回爬取到的数据条目，此外还要将需要跟进的新的 URL 发送给引擎。</p></li><li><p>引擎将抓取到的数据条目送入数据管道，把新的 URL 发送给调度器放入队列中。</p></li></ol><p>上述操作中的第2步到第8步会一直重复直到调度器中没有需要请求的 URL，爬虫就停止工作。</p><h2 id="安装和使用Scrapy"><a href="#安装和使用Scrapy" class="headerlink" title="安装和使用Scrapy"></a>安装和使用Scrapy</h2><p>可以使用 Python 的包管理工具<code>pip</code>来安装 Scrapy。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><p>在命令行中使用<code>scrapy</code>命令创建名为<code>demo</code>的项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject demo</span><br></pre></td></tr></table></figure><p>项目的目录结构如下图所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">|____ demo</span><br><span class="line">|________ spiders</span><br><span class="line">|____________ __init__.py</span><br><span class="line">|________ __init__.py</span><br><span class="line">|________ items.py</span><br><span class="line">|________ middlewares.py</span><br><span class="line">|________ pipelines.py</span><br><span class="line">|________ settings.py</span><br><span class="line">|____ scrapy.cfg</span><br></pre></td></tr></table></figure><p>切换到<code>demo</code> 目录，用下面的命令创建名为<code>douban</code>的蜘蛛程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider douban movie.douban.com</span><br></pre></td></tr></table></figure><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>接下来，我们实现一个爬取豆瓣电影 Top250 电影标题、评分和金句的爬虫。</p><ol><li><p>在<code>items.py</code>的<code>Item</code>类中定义字段，这些字段用来保存数据，方便后续的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanItem</span>(scrapy.Item):</span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br><span class="line">    motto = scrapy.Field()</span><br></pre></td></tr></table></figure></li><li><p>修改<code>spiders</code>文件夹中名为<code>douban.py</code> 的文件，它是蜘蛛程序的核心，需要我们添加解析页面的代码。在这里，我们可以通过对<code>Response</code>对象的解析，获取电影的信息，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector, Request</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> demo.items <span class="keyword">import</span> MovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://movie.douban.com/top250?start=0&amp;filter=&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response: HtmlResponse</span>):</span><br><span class="line">        sel = Selector(response)</span><br><span class="line">        movie_items = sel.css(<span class="string">&#x27;#content &gt; div &gt; div.article &gt; ol &gt; li&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> movie_sel <span class="keyword">in</span> movie_items:</span><br><span class="line">            item = MovieItem()</span><br><span class="line">            item[<span class="string">&#x27;title&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.title::text&#x27;</span>).extract_first()</span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.rating_num::text&#x27;</span>).extract_first()</span><br><span class="line">            item[<span class="string">&#x27;motto&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.inq::text&#x27;</span>).extract_first()</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>通过上面的代码不难看出，我们可以使用 CSS 选择器进行页面解析。当然，如果你愿意也可以使用 XPath 或正则表达式进行页面解析，对应的方法分别是<code>xpath</code>和<code>re</code>。</p><p>如果还要生成后续爬取的请求，我们可以用<code>yield</code>产出<code>Request</code>对象。<code>Request</code>对象有两个非常重要的属性，一个是<code>url</code>，它代表了要请求的地址；一个是<code>callback</code>，它代表了获得响应之后要执行的回调函数。我们可以将上面的代码稍作修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector, Request</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> demo.items <span class="keyword">import</span> MovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://movie.douban.com/top250?start=0&amp;filter=&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response: HtmlResponse</span>):</span><br><span class="line">        sel = Selector(response)</span><br><span class="line">        movie_items = sel.css(<span class="string">&#x27;#content &gt; div &gt; div.article &gt; ol &gt; li&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> movie_sel <span class="keyword">in</span> movie_items:</span><br><span class="line">            item = MovieItem()</span><br><span class="line">            item[<span class="string">&#x27;title&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.title::text&#x27;</span>).extract_first()</span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.rating_num::text&#x27;</span>).extract_first()</span><br><span class="line">            item[<span class="string">&#x27;motto&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.inq::text&#x27;</span>).extract_first()</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        hrefs = sel.css(<span class="string">&#x27;#content &gt; div &gt; div.article &gt; div.paginator &gt; a::attr(&quot;href&quot;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> href <span class="keyword">in</span> hrefs:</span><br><span class="line">            full_url = response.urljoin(href.extract())</span><br><span class="line">            <span class="keyword">yield</span> Request(url=full_url)</span><br></pre></td></tr></table></figure><p>到这里，我们已经可以通过下面的命令让爬虫运转起来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl movie</span><br></pre></td></tr></table></figure><p>可以在控制台看到爬取到的数据，如果想将这些数据保存到文件中，可以通过<code>-o</code>参数来指定文件名，Scrapy 支持我们将爬取到的数据导出成 JSON、CSV、XML 等格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl moive -o result.json</span><br></pre></td></tr></table></figure><p>不知大家是否注意到，通过运行爬虫获得的 JSON 文件中有<code>275</code>条数据，那是因为首页被重复爬取了。要解决这个问题，可以对上面的代码稍作调整，不在<code>parse</code>方法中解析获取新页面的 URL，而是通过<code>start_requests</code>方法提前准备好待爬取页面的 URL，调整后的代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector, Request</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> demo.items <span class="keyword">import</span> MovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;douban&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">yield</span> Request(url=<span class="string">f&#x27;https://movie.douban.com/top250?start=<span class="subst">&#123;page * <span class="number">25</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response: HtmlResponse</span>):</span><br><span class="line">        sel = Selector(response)</span><br><span class="line">        movie_items = sel.css(<span class="string">&#x27;#content &gt; div &gt; div.article &gt; ol &gt; li&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> movie_sel <span class="keyword">in</span> movie_items:</span><br><span class="line">            item = MovieItem()</span><br><span class="line">            item[<span class="string">&#x27;title&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.title::text&#x27;</span>).extract_first()</span><br><span class="line">            item[<span class="string">&#x27;score&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.rating_num::text&#x27;</span>).extract_first()</span><br><span class="line">            item[<span class="string">&#x27;motto&#x27;</span>] = movie_sel.css(<span class="string">&#x27;.inq::text&#x27;</span>).extract_first()</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></li><li><p>如果希望完成爬虫数据的持久化，可以在数据管道中处理蜘蛛程序产生的<code>Item</code>对象。例如，我们可以通过前面讲到的<code>openpyxl</code>操作 Excel 文件，将数据写入 Excel 文件中，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> demo.items <span class="keyword">import</span> MovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovieItemPipeline</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.wb = openpyxl.Workbook()</span><br><span class="line">        self.sheet = self.wb.active</span><br><span class="line">        self.sheet.title = <span class="string">&#x27;Top250&#x27;</span></span><br><span class="line">        self.sheet.append((<span class="string">&#x27;名称&#x27;</span>, <span class="string">&#x27;评分&#x27;</span>, <span class="string">&#x27;名言&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item: MovieItem, spider</span>):</span><br><span class="line">        self.sheet.append((item[<span class="string">&#x27;title&#x27;</span>], item[<span class="string">&#x27;score&#x27;</span>], item[<span class="string">&#x27;motto&#x27;</span>]))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.wb.save(<span class="string">&#x27;豆瓣电影数据.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面的<code>process_item</code>和<code>close_spider</code>都是回调方法（钩子函数）， 简单的说就是 Scrapy 框架会自动去调用的方法。当蜘蛛程序产生一个<code>Item</code>对象交给引擎时，引擎会将该<code>Item</code>对象交给数据管道，这时我们配置好的数据管道的<code>parse_item</code>方法就会被执行，所以我们可以在该方法中获取数据并完成数据的持久化操作。另一个方法<code>close_spider</code>是在爬虫结束运行前会自动执行的方法，在上面的代码中，我们在这个地方进行了保存 Excel 文件的操作，相信这段代码大家是很容易读懂的。</p><p>总而言之，数据管道可以帮助我们完成以下操作：</p><ul><li>清理 HTML 数据，验证爬取的数据。</li><li>丢弃重复的不必要的内容。</li><li>将爬取的结果进行持久化操作。</li></ul></li><li><p>修改<code>settings.py</code>文件对项目进行配置，主要需要修改以下几个配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户浏览器</span></span><br><span class="line">USER_AGENT = <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发请求数量 </span></span><br><span class="line">CONCURRENT_REQUESTS = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载延迟</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">3</span></span><br><span class="line"><span class="comment"># 随机化下载延迟</span></span><br><span class="line">RANDOMIZE_DOWNLOAD_DELAY = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否遵守爬虫协议</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置数据管道</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;demo.pipelines.MovieItemPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面配置文件中的<code>ITEM_PIPELINES</code>选项是一个字典，可以配置多个处理数据的管道，后面的数字代表了执行的优先级，数字小的先执行。</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;用Python获取网络数据&quot;&gt;&lt;a href=&quot;#用Python获取网络数据&quot; class=&quot;headerlink&quot; title=&quot;用Python获取网络数据&quot;&gt;&lt;/a&gt;用Python获取网络数据&lt;/h1&gt;&lt;p&gt;网络数据采集是 Python 语言非常擅长的领域，上节课我们讲到，实现网络数据采集的程序通常称之为网络爬虫或蜘蛛程序。即便是在大数据时代，数据对于中小企业来说仍然是硬伤和短板，有些数据需要通过开放或付费的数据接口来获得，其他的行业数据和竞对数据则必须要通过网络数据采集的方式来获得。不管使用哪种方式获取网络数据资源，Python 语言都是非常好的选择，因为 Python 的标准库和三方库都对网络数据采集提供了良好的支持。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="网络爬虫" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（九）-- 操作excel文件</title>
    <link href="http://example.com/2022/11/01/Python%E8%BF%9B%E9%98%B6(%E4%B9%9D)%E6%93%8D%E4%BD%9Cexcel%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2022/11/01/Python%E8%BF%9B%E9%98%B6(%E4%B9%9D)%E6%93%8D%E4%BD%9Cexcel%E6%96%87%E4%BB%B6/</id>
    <published>2022-11-01T13:23:31.000Z</published>
    <updated>2022-11-17T13:43:37.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用Python读写Excel文件"><a href="#用Python读写Excel文件" class="headerlink" title="用Python读写Excel文件"></a>用Python读写Excel文件</h1><h2 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h2><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p><span id="more"></span>  <p>Python操作Excel需要三方库的支持，如果要兼容Excel 2007以前的版本，也就是<code>xls</code>格式的Excel文件，可以使用三方库<code>xlrd</code>和<code>xlwt</code>，前者用于读Excel文件，后者用于写Excel文件。如果使用较新版本的Excel，即操作<code>xlsx</code>格式的Excel文件，可以使用<code>openpyxl</code>库，当然这个库不仅仅可以操作Excel，还可以操作其他基于Office Open XML的电子表格文件。</p><p>基于<code>xlwt</code>和<code>xlrd</code>操作Excel文件，大家可以先使用下面的命令安装这两个三方库以及配合使用的工具模块<code>xlutils</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xlwt xlrd xlutils</span><br></pre></td></tr></table></figure><h2 id="读Excel文件"><a href="#读Excel文件" class="headerlink" title="读Excel文件"></a>读Excel文件</h2><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xls”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用xlrd模块的open_workbook函数打开指定Excel文件并获得Book对象（工作簿）</span></span><br><span class="line">wb = xlrd.open_workbook(<span class="string">&#x27;阿里巴巴2020年股票数据.xls&#x27;</span>)</span><br><span class="line"><span class="comment"># 通过Book对象的sheet_names方法可以获取所有表单名称</span></span><br><span class="line">sheetnames = wb.sheet_names()</span><br><span class="line"><span class="built_in">print</span>(sheetnames)</span><br><span class="line"><span class="comment"># 通过指定的表单名称获取Sheet对象（工作表）</span></span><br><span class="line">sheet = wb.sheet_by_name(sheetnames[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 通过Sheet对象的nrows和ncols属性获取表单的行数和列数</span></span><br><span class="line"><span class="built_in">print</span>(sheet.nrows, sheet.ncols)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(sheet.nrows):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(sheet.ncols):</span><br><span class="line">        <span class="comment"># 通过Sheet对象的cell方法获取指定Cell对象（单元格）</span></span><br><span class="line">        <span class="comment"># 通过Cell对象的value属性获取单元格中的值</span></span><br><span class="line">        value = sheet.cell(row, col).value</span><br><span class="line">        <span class="comment"># 对除首行外的其他行进行数据格式化处理</span></span><br><span class="line">        <span class="keyword">if</span> row &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 第1列的xldate类型先转成元组再格式化为“年月日”的格式</span></span><br><span class="line">            <span class="keyword">if</span> col == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># xldate_as_tuple函数的第二个参数只有0和1两个取值</span></span><br><span class="line">                <span class="comment"># 其中0代表以1900-01-01为基准的日期，1代表以1904-01-01为基准的日期</span></span><br><span class="line">                value = xlrd.xldate_as_tuple(value, <span class="number">0</span>)</span><br><span class="line">                value = <span class="string">f&#x27;<span class="subst">&#123;value[<span class="number">0</span>]&#125;</span>年<span class="subst">&#123;value[<span class="number">1</span>]:&gt;02d&#125;</span>月<span class="subst">&#123;value[<span class="number">2</span>]:&gt;02d&#125;</span>日&#x27;</span></span><br><span class="line">            <span class="comment"># 其他列的number类型处理成小数点后保留两位有效数字的浮点数</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value = <span class="string">f&#x27;<span class="subst">&#123;value:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(value, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 获取最后一个单元格的数据类型</span></span><br><span class="line"><span class="comment"># 0 - 空值，1 - 字符串，2 - 数字，3 - 日期，4 - 布尔，5 - 错误</span></span><br><span class="line">last_cell_type = sheet.cell_type(sheet.nrows - <span class="number">1</span>, sheet.ncols - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(last_cell_type)</span><br><span class="line"><span class="comment"># 获取第一行的值（列表）</span></span><br><span class="line"><span class="built_in">print</span>(sheet.row_values(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 获取指定行指定列范围的数据（列表）</span></span><br><span class="line"><span class="comment"># 第一个参数代表行索引，第二个和第三个参数代表列的开始（含）和结束（不含）索引</span></span><br><span class="line"><span class="built_in">print</span>(sheet.row_slice(<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xls”可以通过后面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p></blockquote><p>相信通过上面的代码，大家已经了解到了如何读取一个Excel文件，如果想知道更多关于<code>xlrd</code>模块的知识，可以阅读它的<a href="https://xlrd.readthedocs.io/en/latest/">官方文档</a>。</p><h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>写入Excel文件可以通过<code>xlwt</code> 模块的<code>Workbook</code>类创建工作簿对象，通过工作簿对象的<code>add_sheet</code>方法可以添加工作表，通过工作表对象的<code>write</code>方法可以向指定单元格中写入数据，最后通过工作簿对象的<code>save</code>方法将工作簿写入到指定的文件或内存中。下面的代码实现了将<code>5</code>个学生<code>3</code>门课程的考试成绩写入Excel文件的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line">student_names = [<span class="string">&#x27;关羽&#x27;</span>, <span class="string">&#x27;张飞&#x27;</span>, <span class="string">&#x27;赵云&#x27;</span>, <span class="string">&#x27;马超&#x27;</span>, <span class="string">&#x27;黄忠&#x27;</span>]</span><br><span class="line">scores = [[random.randrange(<span class="number">50</span>, <span class="number">101</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 创建工作簿对象（Workbook）</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"><span class="comment"># 创建工作表对象（Worksheet）</span></span><br><span class="line">sheet = wb.add_sheet(<span class="string">&#x27;一年级二班&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加表头数据</span></span><br><span class="line">titles = (<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> index, title <span class="keyword">in</span> <span class="built_in">enumerate</span>(titles):</span><br><span class="line">    sheet.write(<span class="number">0</span>, index, title)</span><br><span class="line"><span class="comment"># 将学生姓名和考试成绩写入单元格</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores)):</span><br><span class="line">    sheet.write(row + <span class="number">1</span>, <span class="number">0</span>, student_names[row])</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores[row])):</span><br><span class="line">        sheet.write(row + <span class="number">1</span>, col + <span class="number">1</span>, scores[row][col])</span><br><span class="line"><span class="comment"># 保存Excel工作簿</span></span><br><span class="line">wb.save(<span class="string">&#x27;考试成绩表.xls&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="调整单元格样式"><a href="#调整单元格样式" class="headerlink" title="调整单元格样式"></a>调整单元格样式</h3><p>在写Excel文件时，我们还可以为单元格设置样式，主要包括字体（Font）、对齐方式（Alignment）、边框（Border）和背景（Background）的设置，<code>xlwt</code>对这几项设置都封装了对应的类来支持。要设置单元格样式需要首先创建一个<code>XFStyle</code>对象，再通过该对象的属性对字体、对齐方式、边框等进行设定，例如在上面的例子中，如果希望将表头单元格的背景色修改为黄色，可以按照如下的方式进行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">header_style = xlwt.XFStyle()</span><br><span class="line">pattern = xlwt.Pattern()</span><br><span class="line">pattern.pattern = xlwt.Pattern.SOLID_PATTERN</span><br><span class="line"><span class="comment"># 0 - 黑色、1 - 白色、2 - 红色、3 - 绿色、4 - 蓝色、5 - 黄色、6 - 粉色、7 - 青色</span></span><br><span class="line">pattern.pattern_fore_colour = <span class="number">5</span></span><br><span class="line">header_style.pattern = pattern</span><br><span class="line">titles = (<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> index, title <span class="keyword">in</span> <span class="built_in">enumerate</span>(titles):</span><br><span class="line">    sheet.write(<span class="number">0</span>, index, title, header_style)</span><br></pre></td></tr></table></figure><p>如果希望为表头设置指定的字体，可以使用<code>Font</code>类并添加如下所示的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">font = xlwt.Font()</span><br><span class="line"><span class="comment"># 字体名称</span></span><br><span class="line">font.name = <span class="string">&#x27;华文楷体&#x27;</span></span><br><span class="line"><span class="comment"># 字体大小（20是基准单位，18表示18px）</span></span><br><span class="line">font.height = <span class="number">20</span> * <span class="number">18</span></span><br><span class="line"><span class="comment"># 是否使用粗体</span></span><br><span class="line">font.bold = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 是否使用斜体</span></span><br><span class="line">font.italic = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 字体颜色</span></span><br><span class="line">font.colour_index = <span class="number">1</span></span><br><span class="line">header_style.font = font</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上面代码中指定的字体名（<code>font.name</code>）应当是本地系统有的字体，例如在我的电脑上有名为“华文楷体”的字体。</p></blockquote><p>如果希望表头垂直居中对齐，可以使用下面的代码进行设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">align = xlwt.Alignment()</span><br><span class="line"><span class="comment"># 垂直方向的对齐方式</span></span><br><span class="line">align.vert = xlwt.Alignment.VERT_CENTER</span><br><span class="line"><span class="comment"># 水平方向的对齐方式</span></span><br><span class="line">align.horz = xlwt.Alignment.HORZ_CENTER</span><br><span class="line">header_style.alignment = align</span><br></pre></td></tr></table></figure><p>如果希望给表头加上黄色的虚线边框，可以使用下面的代码来设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">borders = xlwt.Borders()</span><br><span class="line">props = (</span><br><span class="line">    (<span class="string">&#x27;top&#x27;</span>, <span class="string">&#x27;top_colour&#x27;</span>), (<span class="string">&#x27;right&#x27;</span>, <span class="string">&#x27;right_colour&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;bottom&#x27;</span>, <span class="string">&#x27;bottom_colour&#x27;</span>), (<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;left_colour&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 通过循环对四个方向的边框样式及颜色进行设定</span></span><br><span class="line"><span class="keyword">for</span> position, color <span class="keyword">in</span> props:</span><br><span class="line">    <span class="comment"># 使用setattr内置函数动态给对象指定的属性赋值</span></span><br><span class="line">    <span class="built_in">setattr</span>(borders, position, xlwt.Borders.DASHED)</span><br><span class="line">    <span class="built_in">setattr</span>(borders, color, <span class="number">5</span>)</span><br><span class="line">header_style.borders = borders</span><br></pre></td></tr></table></figure><p>如果要调整单元格的宽度（列宽）和表头的高度（行高），可以按照下面的代码进行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置行高为40px</span></span><br><span class="line">sheet.row(<span class="number">0</span>).set_style(xlwt.easyxf(<span class="string">f&#x27;font:height <span class="subst">&#123;<span class="number">20</span> * <span class="number">40</span>&#125;</span>&#x27;</span>))</span><br><span class="line">titles = (<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> index, title <span class="keyword">in</span> <span class="built_in">enumerate</span>(titles):</span><br><span class="line">    <span class="comment"># 设置列宽为200px</span></span><br><span class="line">    sheet.col(index).width = <span class="number">20</span> * <span class="number">200</span></span><br><span class="line">    <span class="comment"># 设置单元格的数据和样式</span></span><br><span class="line">    sheet.write(<span class="number">0</span>, index, title, header_style)</span><br></pre></td></tr></table></figure><h3 id="公式计算"><a href="#公式计算" class="headerlink" title="公式计算"></a>公式计算</h3><p>对于前面打开的“阿里巴巴2020年股票数据.xls”文件，如果要统计全年收盘价（Close字段）的平均值以及全年交易量（Volume字段）的总和，可以使用Excel的公式计算即可。我们可以先使用<code>xlrd</code>读取Excel文件夹，然后通过<code>xlutils</code>三方库提供的<code>copy</code>函数将读取到的Excel文件转成<code>Workbook</code>对象进行写操作，在调用<code>write</code>方法时，可以将一个<code>Formula</code>对象写入单元格。</p><p>实现公式计算的代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> xlutils.copy <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">wb_for_read = xlrd.open_workbook(<span class="string">&#x27;阿里巴巴2020年股票数据.xls&#x27;</span>)</span><br><span class="line">sheet1 = wb_for_read.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">nrows, ncols = sheet1.nrows, sheet1.ncols</span><br><span class="line">wb_for_write = copy(wb_for_read)</span><br><span class="line">sheet2 = wb_for_write.get_sheet(<span class="number">0</span>)</span><br><span class="line">sheet2.write(nrows, <span class="number">4</span>, xlwt.Formula(<span class="string">f&#x27;average(E2:E<span class="subst">&#123;nrows&#125;</span>)&#x27;</span>))</span><br><span class="line">sheet2.write(nrows, <span class="number">6</span>, xlwt.Formula(<span class="string">f&#x27;sum(G2:G<span class="subst">&#123;nrows&#125;</span>)&#x27;</span>))</span><br><span class="line">wb_for_write.save(<span class="string">&#x27;阿里巴巴2020年股票数据汇总.xls&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面的代码有一些小瑕疵，有兴趣的读者可以自行探索并思考如何解决。</p></blockquote><h1 id="用openpyxl读写Excel文件"><a href="#用openpyxl读写Excel文件" class="headerlink" title="用openpyxl读写Excel文件"></a>用openpyxl读写Excel文件</h1><p>基于另一个三方库<code>openpyxl</code>如何进行Excel文件操作，首先需要先安装它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure><p><code>openpyxl</code>的优点在于，当我们打开一个Excel文件后，既可以对它进行读操作，又可以对它进行写操作，而且在操作的便捷性上是优于<code>xlwt</code>和<code>xlrd</code>的。此外，如果要进行样式编辑和公式计算，使用<code>openpyxl</code>也远比上一个章节我们讲解的方式更为简单，而且<code>openpyxl</code>还支持数据透视和插入图表等操作，功能非常强大。有一点需要再次强调，<code>openpyxl</code>并不支持操作Office 2007以前版本的Excel文件。</p><h2 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h2><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xlsx”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载一个工作簿 ---&gt; Workbook</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">&#x27;阿里巴巴2020年股票数据.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取工作表的名字</span></span><br><span class="line"><span class="built_in">print</span>(wb.sheetnames)</span><br><span class="line"><span class="comment"># 获取工作表 ---&gt; Worksheet</span></span><br><span class="line">sheet = wb.worksheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 获得单元格的范围</span></span><br><span class="line"><span class="built_in">print</span>(sheet.dimensions)</span><br><span class="line"><span class="comment"># 获得行数和列数</span></span><br><span class="line"><span class="built_in">print</span>(sheet.max_row, sheet.max_column)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定单元格的值</span></span><br><span class="line"><span class="built_in">print</span>(sheet.cell(<span class="number">3</span>, <span class="number">3</span>).value)</span><br><span class="line"><span class="built_in">print</span>(sheet[<span class="string">&#x27;C3&#x27;</span>].value)</span><br><span class="line"><span class="built_in">print</span>(sheet[<span class="string">&#x27;G255&#x27;</span>].value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取多个单元格（嵌套元组）</span></span><br><span class="line"><span class="built_in">print</span>(sheet[<span class="string">&#x27;A2:C5&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取所有单元格的数据</span></span><br><span class="line"><span class="keyword">for</span> row_ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, sheet.max_row + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> col_ch <span class="keyword">in</span> <span class="string">&#x27;ABCDEFG&#x27;</span>:</span><br><span class="line">        value = sheet[<span class="string">f&#x27;<span class="subst">&#123;col_ch&#125;</span><span class="subst">&#123;row_ch&#125;</span>&#x27;</span>].value</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(value) == datetime.datetime:</span><br><span class="line">            <span class="built_in">print</span>(value.strftime(<span class="string">&#x27;%Y年%m月%d日&#x27;</span>), end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span>(value) == <span class="built_in">int</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;value:&lt;10d&#125;</span>&#x27;</span>, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span>(value) == <span class="built_in">float</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;value:<span class="number">.4</span>f&#125;</span>&#x27;</span>, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(value, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>需要提醒大家一点，<code>openpyxl</code>获取指定的单元格有两种方式，一种是通过<code>cell</code>方法，需要注意，该方法的行索引和列索引都是从<code>1</code>开始的，这是为了照顾用惯了Excel的人的习惯；另一种是通过索引运算，通过指定单元格的坐标，例如<code>C3</code>、<code>G255</code>，也可以取得对应的单元格，再通过单元格对象的<code>value</code>属性，就可以获取到单元格的值。通过上面的代码，相信大家还注意到了，可以通过类似<code>sheet[&#39;A2:C5&#39;]</code>或<code>sheet[&#39;A2&#39;:&#39;C5&#39;]</code>这样的切片操作获取多个单元格，该操作将返回嵌套的元组，相当于获取到了多行多列。</p><h2 id="写Excel文件-1"><a href="#写Excel文件-1" class="headerlink" title="写Excel文件"></a>写Excel文件</h2><p>下面我们使用<code>openpyxl</code>来进行写Excel操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步：创建工作簿（Workbook）</span></span><br><span class="line">wb = openpyxl.Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：添加工作表（Worksheet）</span></span><br><span class="line">sheet = wb.active</span><br><span class="line">sheet.title = <span class="string">&#x27;期末成绩&#x27;</span></span><br><span class="line"></span><br><span class="line">titles = (<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> col_index, title <span class="keyword">in</span> <span class="built_in">enumerate</span>(titles):</span><br><span class="line">    sheet.cell(<span class="number">1</span>, col_index + <span class="number">1</span>, title)</span><br><span class="line"></span><br><span class="line">names = (<span class="string">&#x27;关羽&#x27;</span>, <span class="string">&#x27;张飞&#x27;</span>, <span class="string">&#x27;赵云&#x27;</span>, <span class="string">&#x27;马超&#x27;</span>, <span class="string">&#x27;黄忠&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> row_index, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line">    sheet.cell(row_index + <span class="number">2</span>, <span class="number">1</span>, name)</span><br><span class="line">    <span class="keyword">for</span> col_index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">5</span>):</span><br><span class="line">        sheet.cell(row_index + <span class="number">2</span>, col_index, random.randrange(<span class="number">50</span>, <span class="number">101</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步：保存工作簿</span></span><br><span class="line">wb.save(<span class="string">&#x27;考试成绩表.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="调整样式和公式计算"><a href="#调整样式和公式计算" class="headerlink" title="调整样式和公式计算"></a>调整样式和公式计算</h3><p>在使用<code>openpyxl</code>操作Excel时，如果要调整单元格的样式，可以直接通过单元格对象（<code>Cell</code>对象）的属性进行操作。单元格对象的属性包括字体（<code>font</code>）、对齐（<code>alignment</code>）、边框（<code>border</code>）等，具体的可以参考<code>openpyxl</code>的<a href="https://openpyxl.readthedocs.io/en/stable/index.html">官方文档</a>。在使用<code>openpyxl</code>时，如果需要做公式计算，可以完全按照Excel中的操作方式来进行，具体的代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Font, Alignment, Border, Side</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对齐方式</span></span><br><span class="line">alignment = Alignment(horizontal=<span class="string">&#x27;center&#x27;</span>, vertical=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment"># 边框线条</span></span><br><span class="line">side = Side(color=<span class="string">&#x27;ff7f50&#x27;</span>, style=<span class="string">&#x27;mediumDashed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">&#x27;考试成绩表.xlsx&#x27;</span>)</span><br><span class="line">sheet = wb.worksheets[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整行高和列宽</span></span><br><span class="line">sheet.row_dimensions[<span class="number">1</span>].height = <span class="number">30</span></span><br><span class="line">sheet.column_dimensions[<span class="string">&#x27;E&#x27;</span>].width = <span class="number">120</span></span><br><span class="line"></span><br><span class="line">sheet[<span class="string">&#x27;E1&#x27;</span>] = <span class="string">&#x27;平均分&#x27;</span></span><br><span class="line"><span class="comment"># 设置字体</span></span><br><span class="line">sheet.cell(<span class="number">1</span>, <span class="number">5</span>).font = Font(size=<span class="number">18</span>, bold=<span class="literal">True</span>, color=<span class="string">&#x27;ff1493&#x27;</span>, name=<span class="string">&#x27;华文楷体&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置对齐方式</span></span><br><span class="line">sheet.cell(<span class="number">1</span>, <span class="number">5</span>).alignment = alignment</span><br><span class="line"><span class="comment"># 设置单元格边框</span></span><br><span class="line">sheet.cell(<span class="number">1</span>, <span class="number">5</span>).border = Border(left=side, top=side, right=side, bottom=side)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="comment"># 公式计算每个学生的平均分</span></span><br><span class="line">    sheet[<span class="string">f&#x27;E<span class="subst">&#123;i&#125;</span>&#x27;</span>] = <span class="string">f&#x27;=average(B<span class="subst">&#123;i&#125;</span>:D<span class="subst">&#123;i&#125;</span>)&#x27;</span></span><br><span class="line">    sheet.cell(i, <span class="number">5</span>).font = Font(size=<span class="number">12</span>, color=<span class="string">&#x27;4169e1&#x27;</span>, italic=<span class="literal">True</span>)</span><br><span class="line">    sheet.cell(i, <span class="number">5</span>).alignment = alignment</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&#x27;考试成绩表.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="生成统计图表"><a href="#生成统计图表" class="headerlink" title="生成统计图表"></a>生成统计图表</h2><p>通过<code>openpyxl</code>库，可以直接向Excel中插入统计图表，具体的做法跟在Excel中插入图表大体一致。我们可以创建指定类型的图表对象，然后通过该对象的属性对图表进行设置。当然，最为重要的是为图表绑定数据，即横轴代表什么，纵轴代表什么，具体的数值是多少。最后，可以将图表对象添加到表单中，具体的代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.chart <span class="keyword">import</span> BarChart, Reference</span><br><span class="line"></span><br><span class="line">wb = Workbook(write_only=<span class="literal">True</span>)</span><br><span class="line">sheet = wb.create_sheet()</span><br><span class="line"></span><br><span class="line">rows = [</span><br><span class="line">    (<span class="string">&#x27;类别&#x27;</span>, <span class="string">&#x27;销售A组&#x27;</span>, <span class="string">&#x27;销售B组&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;手机&#x27;</span>, <span class="number">40</span>, <span class="number">30</span>),</span><br><span class="line">    (<span class="string">&#x27;平板&#x27;</span>, <span class="number">50</span>, <span class="number">60</span>),</span><br><span class="line">    (<span class="string">&#x27;笔记本&#x27;</span>, <span class="number">80</span>, <span class="number">70</span>),</span><br><span class="line">    (<span class="string">&#x27;外围设备&#x27;</span>, <span class="number">20</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向表单中添加行</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    sheet.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建图表对象</span></span><br><span class="line">chart = BarChart()</span><br><span class="line">chart.<span class="built_in">type</span> = <span class="string">&#x27;col&#x27;</span></span><br><span class="line">chart.style = <span class="number">10</span></span><br><span class="line"><span class="comment"># 设置图表的标题</span></span><br><span class="line">chart.title = <span class="string">&#x27;销售统计图&#x27;</span></span><br><span class="line"><span class="comment"># 设置图表纵轴的标题</span></span><br><span class="line">chart.y_axis.title = <span class="string">&#x27;销量&#x27;</span></span><br><span class="line"><span class="comment"># 设置图表横轴的标题</span></span><br><span class="line">chart.x_axis.title = <span class="string">&#x27;商品类别&#x27;</span></span><br><span class="line"><span class="comment"># 设置数据的范围</span></span><br><span class="line">data = Reference(sheet, min_col=<span class="number">2</span>, min_row=<span class="number">1</span>, max_row=<span class="number">5</span>, max_col=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 设置分类的范围</span></span><br><span class="line">cats = Reference(sheet, min_col=<span class="number">1</span>, min_row=<span class="number">2</span>, max_row=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 给图表添加数据</span></span><br><span class="line">chart.add_data(data, titles_from_data=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 给图表设置分类</span></span><br><span class="line">chart.set_categories(cats)</span><br><span class="line">chart.shape = <span class="number">4</span></span><br><span class="line"><span class="comment"># 将图表添加到表单指定的单元格中</span></span><br><span class="line">sheet.add_chart(chart, <span class="string">&#x27;A10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&#x27;demo.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h2><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。如果数据体量较大或者处理数据的方式比较复杂，我们还是推荐大家使用Python数据分析神器之一的<code>pandas</code>库。</p><h1 id="用Python读写CSV文件"><a href="#用Python读写CSV文件" class="headerlink" title="用Python读写CSV文件"></a>用Python读写CSV文件</h1><h2 id="CSV文件介绍"><a href="#CSV文件介绍" class="headerlink" title="CSV文件介绍"></a>CSV文件介绍</h2><p>CSV（Comma Separated Values）全称逗号分隔值文件是一种简单、通用的文件格式，被广泛的应用于应用程序（数据库、电子表格等）数据的导入和导出以及异构系统之间的数据交换。因为CSV是纯文本文件，不管是什么操作系统和编程语言都是可以处理纯文本的，而且很多编程语言中都提供了对读写CSV文件的支持，因此CSV格式在数据处理和数据科学中被广泛应用。</p><p>CSV文件有以下特点：</p><ol><li>纯文本，使用某种字符集（如<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a>、<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>、<a href="https://zh.wikipedia.org/wiki/GB2312">GB2312</a>）等）；</li><li>由一条条的记录组成（典型的是每行一条记录）；</li><li>每条记录被分隔符（如逗号、分号、制表符等）分隔为字段（列）；</li><li>每条记录都有同样的字段序列。</li></ol><p>CSV文件可以使用文本编辑器或类似于Excel电子表格这类工具打开和编辑，当使用Excel这类电子表格打开CSV文件时，你甚至感觉不到CSV和Excel文件的区别。很多数据库系统都支持将数据导出到CSV文件中，当然也支持从CSV文件中读入数据保存到数据库中，这些内容并不是现在要讨论的重点。</p><h2 id="将数据写入CSV文件"><a href="#将数据写入CSV文件" class="headerlink" title="将数据写入CSV文件"></a>将数据写入CSV文件</h2><p>现有五个学生三门课程的考试成绩需要保存到一个CSV文件中，要达成这个目标，可以使用Python标准库中的<code>csv</code>模块，该模块的<code>writer</code>函数会返回一个<code>csvwriter</code>对象，通过该对象的<code>writerow</code>或<code>writerows</code>方法就可以将数据写入到CSV文件中，具体的代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;scores.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>])</span><br><span class="line">    names = [<span class="string">&#x27;关羽&#x27;</span>, <span class="string">&#x27;张飞&#x27;</span>, <span class="string">&#x27;赵云&#x27;</span>, <span class="string">&#x27;马超&#x27;</span>, <span class="string">&#x27;黄忠&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        scores = [random.randrange(<span class="number">50</span>, <span class="number">101</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">        scores.insert(<span class="number">0</span>, name)</span><br><span class="line">        writer.writerow(scores)</span><br></pre></td></tr></table></figure><p>生成的CSV文件的内容。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">姓名,语文,数学,英语</span><br><span class="line">关羽,98,86,61</span><br><span class="line">张飞,86,58,80</span><br><span class="line">赵云,95,73,70</span><br><span class="line">马超,83,97,55</span><br><span class="line">黄忠,61,54,87</span><br></pre></td></tr></table></figure><p>需要说明的是上面的<code>writer</code>函数，除了传入要写入数据的文件对象外，还可以<code>dialect</code>参数，它表示CSV文件的方言，默认值是<code>excel</code>。除此之外，还可以通过<code>delimiter</code>、<code>quotechar</code>、<code>quoting</code>参数来指定分隔符（默认是逗号）、包围值的字符（默认是双引号）以及包围的方式。其中，包围值的字符主要用于当字段中有特殊符号时，通过添加包围值的字符可以避免二义性。大家可以尝试将上面第5行代码修改为下面的代码，然后查看生成的CSV文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer = csv.writer(file, delimiter=<span class="string">&#x27;|&#x27;</span>, quoting=csv.QUOTE_ALL)</span><br></pre></td></tr></table></figure><p>生成的CSV文件的内容。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;姓名&quot;</span><span class="string">|&quot;</span>语文<span class="string">&quot;|&quot;</span>数学<span class="string">&quot;|&quot;</span>英语<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;关羽&quot;</span><span class="string">|&quot;</span><span class="number">88</span><span class="string">&quot;|&quot;</span><span class="number">64</span><span class="string">&quot;|&quot;</span><span class="number">65</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;张飞&quot;</span><span class="string">|&quot;</span><span class="number">76</span><span class="string">&quot;|&quot;</span><span class="number">93</span><span class="string">&quot;|&quot;</span><span class="number">79</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;赵云&quot;</span><span class="string">|&quot;</span><span class="number">78</span><span class="string">&quot;|&quot;</span><span class="number">55</span><span class="string">&quot;|&quot;</span><span class="number">76</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;马超&quot;</span><span class="string">|&quot;</span><span class="number">72</span><span class="string">&quot;|&quot;</span><span class="number">77</span><span class="string">&quot;|&quot;</span><span class="number">68</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;黄忠&quot;</span><span class="string">|&quot;</span><span class="number">70</span><span class="string">&quot;|&quot;</span><span class="number">72</span><span class="string">&quot;|&quot;</span><span class="number">51</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h2 id="从CSV文件读取数据"><a href="#从CSV文件读取数据" class="headerlink" title="从CSV文件读取数据"></a>从CSV文件读取数据</h2><p>如果要读取刚才创建的CSV文件，可以使用下面的代码，通过<code>csv</code>模块的<code>reader</code>函数可以创建出<code>csvreader</code>对象，该对象是一个迭代器，可以通过<code>next</code>函数或<code>for-in</code>循环读取到文件中的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;scores.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file, delimiter=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> data_list <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(reader.line_num, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> data_list:</span><br><span class="line">            <span class="built_in">print</span>(elem, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上面的代码对<code>csvreader</code>对象做<code>for</code>循环时，每次会取出一个列表对象，该列表对象包含了一行中所有的字段。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;用Python读写Excel文件&quot;&gt;&lt;a href=&quot;#用Python读写Excel文件&quot; class=&quot;headerlink&quot; title=&quot;用Python读写Excel文件&quot;&gt;&lt;/a&gt;用Python读写Excel文件&lt;/h1&gt;&lt;h2 id=&quot;Excel简介&quot;&gt;&lt;a href=&quot;#Excel简介&quot; class=&quot;headerlink&quot; title=&quot;Excel简介&quot;&gt;&lt;/a&gt;Excel简介&lt;/h2&gt;&lt;p&gt;Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="操作excel文件" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9Cexcel%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（八）-- 文件操作</title>
    <link href="http://example.com/2022/10/30/Python%E8%BF%9B%E9%98%B6(%E5%85%AB)%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/10/30/Python%E8%BF%9B%E9%98%B6(%E5%85%AB)%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2022-10-30T13:23:31.000Z</published>
    <updated>2022-11-17T13:45:29.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h2><p>无论是文本文件,其操作流程基本一致,即首先打开文件并且创建文件对象,然后通过该文件对象对文件内容进行读取、写入、删除、修改等操作；最后关闭并保存文件内容。Python内置了文件对象，通过open()函数即可以指定模式打开指定文件并创建文件对象,</p><span id="more"></span> <p> 该函数语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file,mode=<span class="string">&#x27;r&#x27;</span>,buffering=-<span class="number">1</span>,encoding=<span class="literal">None</span>,errors=<span class="literal">None</span>,newline=<span class="literal">None</span>,closed=<span class="literal">True</span>,opener=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li>file指定要打开或者创建的文件名称</li><li>mode为打开指定文件后的处理方式</li><li>buffering指定读&#x2F;写的缓存模式,0表示不缓存,1表示行缓存模式,大于1表示缓冲区大小,默认值-1表示二进制文件和非交互式文本文件以固定大小的块为缓存大小</li><li>encoding指定对文本进行编码和解码的方式,只适用于文本模式</li><li>newline只适用于文本模式,取值可以是<code>None</code> <code>“</code> <code>\n</code> <code>\r</code> <code>\r\n</code>中的任何一个,表示文件中新行的形式</li></ul><p>当对文件内容操作完成后,一定要关闭文件对象,这样才能保证所做的任何修改都确实被保存到文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件对象.close()</span><br></pre></td></tr></table></figure><p>文件的常用打开模式及说明:</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>读模式,如果文件不存在抛出异常</td></tr><tr><td>w</td><td>写模式,如果文件已创建,先清空原有内容</td></tr><tr><td>x</td><td>写模式,创建新文件,如果已存在抛出异常</td></tr><tr><td>a</td><td>追加模式,不覆盖文件中原有内容</td></tr><tr><td>b</td><td>二进制模式(可与其他模式组合使用)</td></tr><tr><td>t</td><td>文本模式</td></tr><tr><td>+</td><td>读&#x2F;写模式(可与其他模式组合使用)</td></tr></tbody></table><p>文件对象的常用属性:</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>closed</td><td>判断文件是否关闭,若关闭返回True</td></tr><tr><td>mode</td><td>返回文件的打开模式</td></tr><tr><td>name</td><td>返回文件名称</td></tr></tbody></table><p>文件对象的常用方法及功能说明:</p><table><thead><tr><th>方法</th><th>功能说明</th></tr></thead><tbody><tr><td>flush()</td><td>把缓冲区的内容写入文件,但是不关闭文件</td></tr><tr><td>close()</td><td>把缓冲区的内容写入文件,同时关闭文件,并且释放文件对象</td></tr><tr><td>read([size])</td><td>从文件中读取size个字节或字符的内容作为返回结果,忽略size则读取全部</td></tr><tr><td>readline()</td><td>从文本文件读取一行内容作为返回结果</td></tr><tr><td>readlines()</td><td>从文本文件的每行文本作为一个字符串存入列表,返回列表</td></tr><tr><td>truecate([size])</td><td>删除当前指针位置到末尾的内容,指定size后从size到文件末尾</td></tr><tr><td>write(s)</td><td>把字符串s写入文件</td></tr><tr><td>writelines()</td><td>把字符串列表写入文本文件,不添加换行符</td></tr><tr><td>writeable()</td><td>测试当前文件是否可写</td></tr><tr><td>readable()</td><td>测试当前文件是否可读</td></tr></tbody></table><p>文本文件的写入和读取:</p><ol><li>使用open()打开或则创建文件</li><li>写入字符串到文本文件或则读取文本文件</li><li>关闭文件</li></ol><h2 id="二进制文件操作"><a href="#二进制文件操作" class="headerlink" title="二进制文件操作"></a>二进制文件操作</h2><h3 id="使用pickle模块"><a href="#使用pickle模块" class="headerlink" title="使用pickle模块"></a>使用pickle模块</h3><p>Python标准库中的pickle提供的dump()方法用于将数据进行序列化并写入文件,而load()用于读取二进制文件内容并且返序列化,转换为原来的信息</p><h3 id="使用struct文件"><a href="#使用struct文件" class="headerlink" title="使用struct文件"></a>使用struct文件</h3><ul><li>pack()方法把对象按指定个数进行序列化,然后使用write()将结果写入文件</li><li>使用read()模式读取二进制文件,然后使用unpack()方法反序列化得到原来的信息</li></ul><h1 id="文件与文件夹操作"><a href="#文件与文件夹操作" class="headerlink" title="文件与文件夹操作"></a>文件与文件夹操作</h1><h2 id="os和os-path模块"><a href="#os和os-path模块" class="headerlink" title="os和os.path模块"></a>os和os.path模块</h2><p>os模块除了提供使用操作系统功能和访问文件系统的简便方法之外,还提供了大量文件与文件夹操作。</p><p>os常用方法及其功能：</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>access(path,mode)</td><td>按照mode指定的权限访问文件</td></tr><tr><td>chdir(path)</td><td>把path设为当前工作目录</td></tr><tr><td>chmod(path,mode,*,dir_fd&#x3D;None,follow_symlink&#x3D;True)</td><td>改变文件的访问权限</td></tr><tr><td>extsep</td><td>当前操作系统所使用的文件扩展名为分隔符</td></tr><tr><td>fatat(path)</td><td>返回打开文件的所有属性</td></tr><tr><td>getcwd()</td><td>返回当前工作目录</td></tr><tr><td>listdir()</td><td>返回path目录下的文件和目录文件</td></tr><tr><td>mkdir(path[,mode&#x3D;0777])</td><td>创建目录</td></tr><tr><td>makedirs(path1&#x2F;…&#x2F;pathn,mode&#x3D;511)</td><td>创建多级目录</td></tr><tr><td>open(path,mode)</td><td>按照mode指定权限打开path指定文件</td></tr><tr><td>rmdir(path)</td><td>删除目录</td></tr><tr><td>remove(path)</td><td>删除指定文件</td></tr><tr><td>removedirs(path1&#x2F;path2…)</td><td>删除多级目录</td></tr><tr><td>rename(src,dst)</td><td>重命名文件或目录</td></tr><tr><td>write(fd,data)</td><td>将bytes对象data写入文件fd</td></tr></tbody></table><p>os.path模块提供了大量用于路径判断、切分、连接以及文件夹遍历的方法。</p><table><thead><tr><th>方法</th><th>功能说明</th></tr></thead><tbody><tr><td>abspath(path)</td><td>返回给定路径绝对路径</td></tr><tr><td>basename(path)</td><td>返回路径的最后一个组成部分</td></tr><tr><td>commonpath(paths)</td><td>返回给定的多个路径的最长公共路径</td></tr><tr><td>commonprefix(paths)</td><td>返回给定路径的最长公共前缀</td></tr><tr><td>dirname(p)</td><td>返回给定路径的文件夹部分</td></tr><tr><td>exists(path)</td><td>判断文件是否存在</td></tr><tr><td>getatime(filename)</td><td>返回文件的最后访问时间</td></tr><tr><td>getmtime(fielname)</td><td>返回文件的最后修改时间</td></tr><tr><td>getctime(filename)</td><td>返回文件的创建时间</td></tr><tr><td>getsize(filename)</td><td>返回文件的大小</td></tr><tr><td>isabs(path)</td><td>判断path是否为绝对路径</td></tr><tr><td>isdir(path)</td><td>判断path是否为文件夹</td></tr><tr><td>isfile(path)</td><td>判断path是否为文件</td></tr><tr><td>join(path,*paths)</td><td>连接两个或则多个path</td></tr><tr><td>split(path)</td><td>对路径进行分割,以列表形式分割</td></tr><tr><td>splitext(path)</td><td>从路径中分隔开文件的扩展名</td></tr><tr><td>splitdrive(path)</td><td>从路径中分割驱动器的名称</td></tr></tbody></table><h2 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h2><p>shuilt模块提供了大量的方法支持文件和文件夹操作</p><p>常用方法及其说明:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>copyfile(src,dat)</td><td>复制文件</td></tr><tr><td>copytree(src,dat)</td><td>递归复制文件夹</td></tr><tr><td>disk_usage(path)</td><td>查看磁盘使用情况</td></tr><tr><td>move(src,dst)</td><td>移动文件或递归移动文件夹</td></tr><tr><td>rmtree(path)</td><td>递归删除文件夹</td></tr><tr><td>make_archive(base_name,format,root_dir&#x3D;None,base_dir&#x3D;None)</td><td>创建压缩文件或者zip格式压缩文件</td></tr><tr><td>unpack_archive(filename,extract_dir&#x3D;None,format&#x3D;None)</td><td>解压缩文件</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;文件操作&quot;&gt;&lt;a href=&quot;#文件操作&quot; class=&quot;headerlink&quot; title=&quot;文件操作&quot;&gt;&lt;/a&gt;文件操作&lt;/h1&gt;&lt;h2 id=&quot;文件对象&quot;&gt;&lt;a href=&quot;#文件对象&quot; class=&quot;headerlink&quot; title=&quot;文件对象&quot;&gt;&lt;/a&gt;文件对象&lt;/h2&gt;&lt;p&gt;无论是文本文件,其操作流程基本一致,即首先打开文件并且创建文件对象,然后通过该文件对象对文件内容进行读取、写入、删除、修改等操作；最后关闭并保存文件内容。Python内置了文件对象，通过open()函数即可以指定模式打开指定文件并创建文件对象,&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="文件操作" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（七）-- 正则表达式</title>
    <link href="http://example.com/2022/10/25/Python%E8%BF%9B%E9%98%B6(%E4%B8%83)%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2022/10/25/Python%E8%BF%9B%E9%98%B6(%E4%B8%83)%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-10-25T13:23:31.000Z</published>
    <updated>2022-11-17T13:50:50.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式又称为规则表达式.正则表达式通常用于检索、替换那些符合那些符合摸个规则的文本。</p><span id="more"></span>  <p>作用：</p><ul><li>测试字符串的某个模式，即数据有效性验证</li><li>实现按照某种规则替换文本</li><li>根据模式匹配从字符串中提取一个子字符串</li></ul><p>构成：</p><ul><li>原子（普通字符，如英文字母）</li><li>元字符（有特殊功能的字符）</li><li>模式修正字符</li></ul><h2 id="匹配单字符"><a href="#匹配单字符" class="headerlink" title="匹配单字符"></a>匹配单字符</h2><table><thead><tr><th>字符</th><th>匹配范围</th></tr></thead><tbody><tr><td>.</td><td>匹配任意1个字符（除了\n）</td></tr><tr><td>[]</td><td>匹配[]中列举的字符</td></tr><tr><td>\d</td><td>匹配数字0-9</td></tr><tr><td>\D</td><td>匹配非数字</td></tr><tr><td>\s</td><td>匹配空白，即空格，\t-Tab键，\n换行</td></tr><tr><td>\S</td><td>匹配非空白</td></tr><tr><td>\w</td><td>匹配单词字符，即a-z，A-Z，0-9，_</td></tr><tr><td>\W</td><td>匹配非单词字符</td></tr></tbody></table><h2 id="匹配多个字符"><a href="#匹配多个字符" class="headerlink" title="匹配多个字符"></a>匹配多个字符</h2><table><thead><tr><th align="left">字符</th><th>功能</th></tr></thead><tbody><tr><td align="left">*</td><td>匹配前一个字符出现0次或多次，即可有可无</td></tr><tr><td align="left">+</td><td>匹配前一个字符出现1次或多次，即至少出现一次</td></tr><tr><td align="left">？</td><td>匹配前一个字符出现0次或1次，即要么出现一次要么不出现</td></tr><tr><td align="left">{m}</td><td>匹配前一个字符出现m次</td></tr><tr><td align="left">{m,n}</td><td>匹配前一个字符出现m到n次</td></tr></tbody></table><p>匹配开头结尾</p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td></tr></tbody></table><p>注意：当^在[]中时表示取反：[^h]匹配不是h的字符</p><p>匹配分组</p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>|</td><td>匹配左右任意一个表达式</td></tr><tr><td>(ab)</td><td>将括号中的字符作为一个分组</td></tr><tr><td>\num</td><td>引用分组num匹配到的字符串</td></tr><tr><td>(?P&lt;name&gt;)</td><td>分组起别名</td></tr><tr><td>(?P&#x3D;name)</td><td>引用别名为name分组匹配到的字符串</td></tr></tbody></table><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><h2 id="match匹配"><a href="#match匹配" class="headerlink" title="match匹配"></a>match匹配</h2><p><code>re.match(pattern,string,flags=0)</code>:</p><p>&#x3D;&#x3D;从头匹配&#x3D;&#x3D;一个符合规则的字符串，从&#x3D;&#x3D;起始位置&#x3D;&#x3D;开始匹配，匹配成功返回一个对象，未成功返回None</p><ul><li>pattern：正则模型</li><li>string：要匹配的字符串</li><li>faigs：匹配模式</li></ul><p>match()方法一旦匹配成功，就是一个match object对象，有以下方法：</p><ul><li>group():返回被re匹配的字符串</li><li>start():返回匹配开始的位置</li><li>end():返回匹配结束的位置</li><li>span():返回一个元组包含匹配（开始，结束）的位置</li></ul><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1 导入模块</span></span><br><span class="line"><span class="string">2. 通过match验证正则</span></span><br><span class="line"><span class="string">3. 判断验证是否正确</span></span><br><span class="line"><span class="string">4. 如果成功获取匹配结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 1 导入模块</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&#x27;hahazhong@qq.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 通过match验证正则</span></span><br><span class="line">result = re.match(<span class="string">&#x27;\w*@qq\.com&#x27;</span>, str1)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 3. 判断验证是否正确</span></span><br><span class="line"><span class="comment"># 4. 如果成功获取匹配结果</span></span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;匹配成功&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;匹配结果:&#x27;</span>, result.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;匹配失败&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="search搜索匹配"><a href="#search搜索匹配" class="headerlink" title="search搜索匹配"></a>search搜索匹配</h2><p><code>re.search(pattern,string,flags=0)</code>:</p><p>从需要检测的字符串中&#x3D;&#x3D;搜索&#x3D;&#x3D;一个符合规则的字符串，搜索成功返回一个对象，未成功返回None,其余和match()相同</p><p>match()和search()区别:&#x3D;&#x3D;match()只检测RE是否在string的开始位置匹配,search()会扫描整个string查找匹配&#x3D;&#x3D;</p><h2 id="findall查找所有"><a href="#findall查找所有" class="headerlink" title="findall查找所有"></a>findall查找所有</h2><p><code>re.findall(pattern,string,flags=0)</code>:</p><p>遍历匹配字符串中所有匹配的字符串,返回一个列表</p><p>如果匹配的正则里含有分组,则会返回分组内容打包的元组列表</p><h2 id="sub替换"><a href="#sub替换" class="headerlink" title="sub替换"></a>sub替换</h2><p><code>re.sub(pattern,newstring,string)</code>:</p><ul><li>newstring：替换的字符串</li></ul><p>使用re替换string中每一个匹配的子串返回替换后的字符串。</p><h2 id="split分割"><a href="#split分割" class="headerlink" title="split分割"></a>split分割</h2><p><code>re.split(pattern,newstring,string)</code>:</p><p>按照正则拆分字符串，返回值为一个列表。</p><h2 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h2><p>Python中数量词是贪婪的（少数语言为非贪婪），总是尽可能多的字符；非贪婪则相反，总是尽可能匹配少的字符。</p><p>在<code>.</code>、<code>？</code>、<code>+</code>、<code>&#123;m,n&#125;</code>后加上？，使贪婪变成非贪婪。</p><p>模式修正符:</p><p>re.S:使正则表达式中的.匹配到换行符</p><p>re.I:使正则表达式中忽略大小写</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;正则表达式又称为规则表达式.正则表达式通常用于检索、替换那些符合那些符合摸个规则的文本。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（六）-- 高级语法</title>
    <link href="http://example.com/2022/10/21/Python%E8%BF%9B%E9%98%B6(%E5%85%AD)%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/10/21/Python%E8%BF%9B%E9%98%B6(%E5%85%AD)%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/</id>
    <published>2022-10-21T13:23:31.000Z</published>
    <updated>2022-11-17T13:41:49.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIL全局解释锁"><a href="#GIL全局解释锁" class="headerlink" title="GIL全局解释锁"></a>GIL全局解释锁</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>GIL锁:Global Interpreter Lock,又称为全局解释锁。</p><p>任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。GIL锁实际上把所有线程的执行代码都给上了锁。所以，多线程在Python中智能交替执行，即使100个线程跑在100核CPU上也只能用到一核。</p><span id="more"></span>  <h2 id="GIL锁不是Python特性"><a href="#GIL锁不是Python特性" class="headerlink" title="GIL锁不是Python特性"></a>GIL锁不是Python特性</h2><p>GIL是Python解释器（Cpython）时引入的概念，在JPython、PyPy中没有GIL.GIL并不是Python的语言缺陷。是解释器层级的锁，跟Python语言特性无关</p><h2 id="GIL存在原因"><a href="#GIL存在原因" class="headerlink" title="GIL存在原因"></a>GIL存在原因</h2><ol><li>早期计算机都是单核设计</li><li>CPython在执行多线程时并不是线程安全的，所以为了程序的稳定性，加一把全局解释锁，能够确保任何时候都只有宇哥Python线程执行</li></ol><h2 id="GIL的弊端"><a href="#GIL的弊端" class="headerlink" title="GIL的弊端"></a>GIL的弊端</h2><ul><li>对计算密集型的程序产生影响，因为计算密集型的程序，需要占用系统资源</li><li>GIL的存在，相当于始终在进行单线程运算</li><li>IO密集型影响不大的原因在于，IO，input、output，这两个词就表明程序的瓶颈在于输入所耗费的时间，线程大部分时间在等待</li></ul><h2 id="GIL锁释放"><a href="#GIL锁释放" class="headerlink" title="GIL锁释放"></a>GIL锁释放</h2><ul><li>在当前线程执行超时后会自动释放</li><li>在当前线程指向阻塞操作时会自动释放</li><li>当前执行完成时</li></ul><h2 id="GIL解决方案"><a href="#GIL解决方案" class="headerlink" title="GIL解决方案"></a>GIL解决方案</h2><p>由于GIL锁的原因，导致多线程并不能很好地利用CPU资源，所以需要解决GIL锁的问题</p><ol><li><p>换解释器</p></li><li><p>使用多进程替换多线程</p></li><li><p>使用Python特性：胶水，让子线程用c语言来写</p><ul><li>将c语言写的子线程编译为.so文件</li><li>使用ctypes加载.so文件</li><li>开启多线程</li></ul></li></ol><h1 id="Python中的可变和不可变"><a href="#Python中的可变和不可变" class="headerlink" title="Python中的可变和不可变"></a>Python中的可变和不可变</h1><p>可变与不可变是指内存中的那块内容是否可以被改变</p><ul><li><p>可变类型(mutable),创建后可以继续修改对象的内容,如字典、列表</p></li><li><p>不可变类型（unmutable），一旦创建不可修改内容，如数字、字符串、元组</p></li></ul><p>验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 数值</span></span><br><span class="line"><span class="comment"># a = 5</span></span><br><span class="line"><span class="comment"># print(&#x27;a的值为:&#x27;, a, &#x27;\na的内存地址为:&#x27;, id(a))</span></span><br><span class="line"><span class="comment"># # 改变后内存会重新赋予一个内存地址</span></span><br><span class="line"><span class="comment"># a = 5 + 1</span></span><br><span class="line"><span class="comment"># print(&#x27;a的值为:&#x27;, a, &#x27;\na的内存地址为:&#x27;, id(a))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 字符串</span></span><br><span class="line"><span class="comment"># b = &#x27;hahazhong&#x27;</span></span><br><span class="line"><span class="comment"># print(&#x27;b的值为:&#x27;, b, &#x27;\nb的内存地址为:&#x27;, id(b))</span></span><br><span class="line"><span class="comment"># # 改变后内存会重新赋予一个内存地址</span></span><br><span class="line"><span class="comment"># b = &#x27;hahazhong&#x27; + &#x27;120&#x27;</span></span><br><span class="line"><span class="comment"># print(&#x27;改变后b的值为:&#x27;, b, &#x27;\nb的内存地址为:&#x27;, id(b))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = <span class="built_in">id</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;------<span class="subst">&#123;<span class="built_in">type</span>(a)&#125;</span>------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;原来的值为: <span class="subst">&#123;a&#125;</span> \n内存地址为: <span class="subst">&#123;<span class="built_in">id</span>(a)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 改变后内存会重新赋予一个内存地址</span></span><br><span class="line">    a += b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;改变后的值为:<span class="subst">&#123;a&#125;</span> \n内存地址为: <span class="subst">&#123;<span class="built_in">id</span>(a)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">id</span>(a) == c:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;内存地址未改变&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;内存地址改变&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">test(a, a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">b = <span class="string">&#x27;哈哈钟&#x27;</span></span><br><span class="line">test(b, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组</span></span><br><span class="line">c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">test(c, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">test(d, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典</span></span><br><span class="line">e = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">f = &#123;<span class="string">&#x27;5&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;------<span class="subst">&#123;<span class="built_in">type</span>(e)&#125;</span>------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;原来的值为: <span class="subst">&#123;e&#125;</span> \n内存地址为: <span class="subst">&#123;<span class="built_in">id</span>(e)&#125;</span>&#x27;</span>)</span><br><span class="line">e.update(f)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;改变后的值为: <span class="subst">&#123;e&#125;</span> \n内存地址为: <span class="subst">&#123;<span class="built_in">id</span>(e)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>python中的copy模块，可以实现拷贝功能</p><ul><li><p>浅拷贝</p><p>引用（地址）拷贝，并没有产生新的空间。如果拷贝的是对象，原对象和copy对象都指向同一个内存空间，只拷贝父对象，不会拷贝对象的内部的子对象。</p><p>用法：<code>copy.copy(变量)</code>进行拷贝</p></li><li><p>深拷贝</p><p>会产生新的空间.如果拷贝的是对象,原对象和copy都指向不同的内存空间,会拷贝对象及其子对象(产生新的空间)</p><p>用法:<code>copy.deepcopy(变量名)</code></p></li></ul><p>作用:</p><ol><li>减少内存的使用</li><li>以后在做数据的清洗、修改或者入库时，对源数据进行复制一份，以防数据修改后找不到源数据</li></ol><h3 id="简单可变类型深浅拷贝"><a href="#简单可变类型深浅拷贝" class="headerlink" title="简单可变类型深浅拷贝"></a>简单可变类型深浅拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @object   : 可变类型深浅拷贝都会产生新的空间,通过对列表进想赋值和深浅拷贝熟悉深浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list1的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list1))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line"><span class="comment"># 赋值后list4的值修改list1也会改变,无法保证数据独立性</span></span><br><span class="line">list4 = list1</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list4的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list4))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">list4.append(<span class="number">77</span>)</span><br><span class="line"><span class="built_in">print</span>(list1, <span class="string">&#x27;list1的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(list4, <span class="string">&#x27;list4的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list4))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 浅拷贝</span></span><br><span class="line"></span><br><span class="line">list2 = copy.copy(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list2的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list2))</span><br><span class="line">list2.append(<span class="number">88</span>)</span><br><span class="line"><span class="built_in">print</span>(list1, <span class="string">&#x27;list1的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list2的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list2))</span><br><span class="line"><span class="comment"># 结论:可变类型浅拷贝也会产生新的空间地址,保证数据独立性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 深拷贝</span></span><br><span class="line"><span class="comment"># 可变类型深拷贝会产生新的空间地址,保证数据独立性</span></span><br><span class="line">list3 = copy.deepcopy(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list3的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list3))</span><br><span class="line">list3.append(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(list1, <span class="string">&#x27;list1的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list3的内存地址为:&#x27;</span>, <span class="built_in">id</span>(list3))</span><br></pre></td></tr></table></figure><p>总结:</p><ol><li><p>浅拷贝:</p><ul><li>不会产生新的空间</li><li>源对象和副本对象指向同一个空间</li><li>如果拷贝的对象,子对象不会拷贝</li></ul></li><li><p>深拷贝:</p><ul><li>产生新的空间</li><li>能够保持各自独立性</li><li>如果拷贝的是对象,子对象不会拷贝</li></ul><p>简单可变类型不管深拷贝还是浅拷贝都会产生新的空间,保持各自独立性</p></li></ol><h3 id="复杂可变类型的深浅拷贝"><a href="#复杂可变类型的深浅拷贝" class="headerlink" title="复杂可变类型的深浅拷贝"></a>复杂可变类型的深浅拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @date     : 2022/11/2 16:40</span></span><br><span class="line"><span class="comment"># @author   : hahazhong</span></span><br><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 熟悉复杂类型的深浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"><span class="built_in">list</span> = [a, b]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span>, a, <span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b=&#x27;</span>, b, <span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list=&#x27;</span>, <span class="built_in">list</span>, <span class="built_in">id</span>(<span class="built_in">list</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list[0]=&#x27;</span>, <span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">id</span>(<span class="built_in">list</span>[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list[1]=&#x27;</span>, <span class="built_in">list</span>[<span class="number">1</span>], <span class="built_in">id</span>(<span class="built_in">list</span>[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"><span class="comment"># # 赋值</span></span><br><span class="line"><span class="comment"># list4 = list</span></span><br><span class="line"><span class="comment"># list4[0].append(0)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(&#x27;list=&#x27;, list, id(list))</span></span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"><span class="comment"># print(&#x27;list[0]=&#x27;, list[0], id(list[0]))</span></span><br><span class="line"><span class="comment"># print(&#x27;list[1]=&#x27;, list[1], id(list[1]))</span></span><br><span class="line"><span class="comment"># print(&#x27;list4=&#x27;, list4, id(list4))</span></span><br><span class="line"><span class="comment"># print(&#x27;list4[0]=&#x27;, list4[0], id(list4[0]))</span></span><br><span class="line"><span class="comment"># print(&#x27;list4[1]=&#x27;, list4[1], id(list4[1]))</span></span><br><span class="line"><span class="comment"># # 结论: 复杂可变类型赋值会使原数据进行改变</span></span><br><span class="line"><span class="comment"># print(&#x27;--&#x27; * 10)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 对复杂可变类型进行浅拷贝</span></span><br><span class="line"><span class="comment"># list2 = copy.copy(list)</span></span><br><span class="line"><span class="comment"># print(&#x27;list2=&#x27;, list2, id(list2))</span></span><br><span class="line"><span class="comment"># print(&#x27;list2[0]=&#x27;, list2[0], id(list2[0]))</span></span><br><span class="line"><span class="comment"># print(&#x27;list2[1]=&#x27;, list2[1], id(list2[1]))</span></span><br><span class="line"><span class="comment"># list2[0].append(12)</span></span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"><span class="comment"># print(&#x27;list2=&#x27;, list2, id(list2))</span></span><br><span class="line"><span class="comment"># print(&#x27;list2[0]=&#x27;, list2[0], id(list2[0]))</span></span><br><span class="line"><span class="comment"># print(&#x27;list2[1]=&#x27;, list2[1], id(list2[1]))</span></span><br><span class="line"><span class="comment"># # 结论:浅拷贝只复制最顶层函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 对复杂可变类型进行深拷贝</span></span><br><span class="line">list3 = copy.deepcopy(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list3=&#x27;</span>, list3, <span class="built_in">id</span>(list3))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list3[0]=&#x27;</span>, list3[<span class="number">0</span>], <span class="built_in">id</span>(list3[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list3[1]=&#x27;</span>, list3[<span class="number">1</span>], <span class="built_in">id</span>(list3[<span class="number">1</span>]))</span><br><span class="line">list3[<span class="number">0</span>].append(<span class="number">88</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list3=&#x27;</span>, list3, <span class="built_in">id</span>(list3))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list3[0]=&#x27;</span>, list3[<span class="number">0</span>], <span class="built_in">id</span>(list3[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list3[1]=&#x27;</span>, list3[<span class="number">1</span>], <span class="built_in">id</span>(list3[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><h3 id="简单不可变类型拷贝"><a href="#简单不可变类型拷贝" class="headerlink" title="简单不可变类型拷贝"></a>简单不可变类型拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(tup, <span class="string">&#x27;tup地址:&#x27;</span>, <span class="built_in">id</span>(tup))</span><br><span class="line"></span><br><span class="line">tup1 = copy.copy(tup)</span><br><span class="line"><span class="built_in">print</span>(tup1, <span class="string">&#x27;tup1的地址:&#x27;</span>, <span class="built_in">id</span>(tup1))</span><br><span class="line"></span><br><span class="line">tup2 = copy.deepcopy(tup1)</span><br><span class="line"><span class="built_in">print</span>(tup2, <span class="string">&#x27;tup2的地址:&#x27;</span>, <span class="built_in">id</span>(tup2))</span><br></pre></td></tr></table></figure><p>总结:</p><p>不可变类型的深浅拷贝都会拷贝原地址</p><h3 id="复杂不可变类型拷贝"><a href="#复杂不可变类型拷贝" class="headerlink" title="复杂不可变类型拷贝"></a>复杂不可变类型拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅拷贝</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_copy</span>():</span><br><span class="line">    list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    list2 = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    <span class="comment"># 定义元组</span></span><br><span class="line">    <span class="built_in">tuple</span> = (list1, list2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">tuple</span>, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(<span class="built_in">tuple</span>))</span><br><span class="line">    <span class="comment"># 浅拷贝</span></span><br><span class="line">    tuple2 = copy.copy(<span class="built_in">tuple</span>)</span><br><span class="line">    <span class="built_in">print</span>(tuple2, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(tuple2))</span><br><span class="line">    <span class="comment"># tuple2并没有产生新的地址空间</span></span><br><span class="line">    <span class="comment"># 对tuple中的可变类型进行改变,tuple和tuple2的值也会改变.--也就是说不可变类型浅拷贝也只是拷贝顶层地址</span></span><br><span class="line">    list1.append(<span class="number">22</span>)</span><br><span class="line">    <span class="built_in">print</span>(tuple2, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(tuple2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_deepcopy</span>():</span><br><span class="line">    <span class="comment"># 不可变嵌套可变</span></span><br><span class="line">    list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    list2 = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    <span class="comment"># 定义元组</span></span><br><span class="line">    <span class="built_in">tuple</span> = (list1, list2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">tuple</span>, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(<span class="built_in">tuple</span>))</span><br><span class="line">    <span class="comment"># 深拷贝</span></span><br><span class="line">    tuple2 = copy.deepcopy(<span class="built_in">tuple</span>)</span><br><span class="line">    <span class="built_in">print</span>(tuple2, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(tuple2))</span><br><span class="line">    <span class="comment"># tuple2产生新的地址空间</span></span><br><span class="line">    <span class="comment"># 对tuple中的可变类型进行改变,tuple2的值不会改变.--也就是说不可变类型深拷贝对顶层和底层地址全部建立了新的空间</span></span><br><span class="line">    list1.append(<span class="number">22</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">tuple</span>, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(<span class="built_in">tuple</span>))</span><br><span class="line">    <span class="built_in">print</span>(tuple2, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(tuple2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 不可变嵌套不可变</span></span><br><span class="line">    tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    tup2 = (<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="comment"># 定义元组</span></span><br><span class="line">    <span class="built_in">tuple</span> = (tup1, tup2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">tuple</span>, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(<span class="built_in">tuple</span>))</span><br><span class="line">    <span class="comment"># 深拷贝</span></span><br><span class="line">    <span class="comment"># 嵌套全部为不可变时,不会产生新的地址空间</span></span><br><span class="line">    tuple2 = copy.deepcopy(<span class="built_in">tuple</span>)</span><br><span class="line">    <span class="built_in">print</span>(tuple2, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(tuple2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_copy()</span></span><br><span class="line">test_deepcopy()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结:</p><ul><li>浅拷贝直接引用原数据地址</li><li>深拷贝要看数据具体可变还是不可变,如果数据可变,会产生新的空间</li></ul><h2 id="切片拷贝和字典拷贝"><a href="#切片拷贝和字典拷贝" class="headerlink" title="切片拷贝和字典拷贝"></a>切片拷贝和字典拷贝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @date     : 2022/11/7 22:21</span></span><br><span class="line"><span class="comment"># @author   : hahazhong</span></span><br><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 进行切片拷贝和字典拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    <span class="built_in">print</span>(list1, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(list1))</span><br><span class="line">    <span class="comment"># 简单类型切片拷贝</span></span><br><span class="line">    list2 = list1[:]</span><br><span class="line">    <span class="built_in">print</span>(list2, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(list2))</span><br><span class="line">    <span class="comment"># 对原数据进行修改</span></span><br><span class="line">    list1[<span class="number">2</span>] = <span class="number">88</span></span><br><span class="line">    <span class="built_in">print</span>(list2, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(list2))</span><br><span class="line">    <span class="comment"># 简单类型切片拷贝会产生新地址,数据独立</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test1()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="comment"># 复杂类型拷贝</span></span><br><span class="line">    A = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    B = [<span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>]</span><br><span class="line">    <span class="comment"># C=[A,B]</span></span><br><span class="line">    C = (A, B)</span><br><span class="line">    <span class="built_in">print</span>(C, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(C))</span><br><span class="line">    D = C[:]</span><br><span class="line">    <span class="built_in">print</span>(D, <span class="string">&#x27;地址为:&#x27;</span>, <span class="built_in">id</span>(D))</span><br><span class="line">    <span class="comment"># 对于复杂类型进行切片拷贝,如果为可变类型为深拷贝,如果不可变类型为浅拷贝</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test2()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_dict1</span>():</span><br><span class="line">    <span class="comment"># 字典拷贝(值为不可变类型)</span></span><br><span class="line">    dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;哈哈钟&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;age&#x27;</span>: <span class="number">188</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(dict1, <span class="string">&#x27;dict地址为&#x27;</span>, <span class="built_in">id</span>(dict1))</span><br><span class="line">    dict2 = dict1.copy()</span><br><span class="line">    <span class="built_in">print</span>(dict2, <span class="string">&#x27;dict2地址为&#x27;</span>, <span class="built_in">id</span>(dict2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 修改数据</span></span><br><span class="line">    dict1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">21</span></span><br><span class="line">    <span class="built_in">print</span>(dict1, <span class="string">&#x27;dict地址为&#x27;</span>, <span class="built_in">id</span>(dict1))</span><br><span class="line">    <span class="built_in">print</span>(dict2, <span class="string">&#x27;dict2地址为&#x27;</span>, <span class="built_in">id</span>(dict2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_dict1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_dict2</span>():</span><br><span class="line">    <span class="comment"># 字典拷贝(值为可变类型)</span></span><br><span class="line">    dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;哈哈钟&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;age&#x27;</span>: [<span class="number">188</span>, <span class="number">21</span>]&#125;</span><br><span class="line">    <span class="built_in">print</span>(dict1, <span class="string">&#x27;dict地址为&#x27;</span>, <span class="built_in">id</span>(dict1))</span><br><span class="line">    dict2 = dict1.copy()</span><br><span class="line">    <span class="built_in">print</span>(dict2, <span class="string">&#x27;dict2地址为&#x27;</span>, <span class="built_in">id</span>(dict2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--&#x27;</span> * <span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 修改数据</span></span><br><span class="line">    dict1[<span class="string">&#x27;age&#x27;</span>][<span class="number">0</span>] = <span class="number">21</span></span><br><span class="line">    <span class="built_in">print</span>(dict1, <span class="string">&#x27;dict地址为&#x27;</span>, <span class="built_in">id</span>(dict1))</span><br><span class="line">    <span class="built_in">print</span>(dict2, <span class="string">&#x27;dict2地址为&#x27;</span>, <span class="built_in">id</span>(dict2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_dict2()</span><br><span class="line"><span class="comment"># 对于字典拷贝如果字典的值的类型为不可变类型,会产生新的地址,为深拷贝</span></span><br><span class="line"><span class="comment"># 对于字典拷贝如果字典的值的类型为可变类型,会产生新的地址,但是只拷贝顶层地址,如果底层进行变动,新地址也会变动.与复杂可变类型的拷贝类似</span></span><br></pre></td></tr></table></figure><p>总结:</p><p>切片拷贝:</p><ul><li>简单类型切片拷贝会产生新地址,数据独立</li><li>对于复杂类型进行切片拷贝,如果为可变类型为深拷贝,如果不可变类型为浅拷贝</li></ul><p>字典拷贝:</p><ul><li><p>对于字典拷贝如果字典的值的类型为不可变类型,会产生新的地址,为深拷贝</p></li><li><p>对于字典拷贝如果字典的值的类型为可变类型,会产生新的地址,但是只拷贝顶层地址,如果底层进行变动,新地址也会变动.与复杂可变类型的拷贝类似</p></li></ul><h1 id="import导入模块"><a href="#import导入模块" class="headerlink" title="import导入模块"></a>import导入模块</h1><h2 id="import导入模块路径问题"><a href="#import导入模块路径问题" class="headerlink" title="import导入模块路径问题"></a>import导入模块路径问题</h2><p>问题: 当我们把模块文件放到工程文件加的外部的文件,发现无法正常引入模块</p><p>原因: 外部文件夹的路径,没有放到环境变量中</p><p>解决方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统的path 环境变量</span></span><br><span class="line"><span class="comment"># 1 导入模块 sys</span></span><br><span class="line"><span class="comment"># 2 sys.path查看到环境变量的具体内容</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> sys.path:</span><br><span class="line">    <span class="built_in">print</span>(path)</span><br><span class="line"><span class="comment"># 将指定的路径加入到环境变量</span></span><br><span class="line">sys.path.append(<span class="string">&#x27;模块所在位置目录&#x27;</span>)  <span class="comment"># 追加到末尾</span></span><br><span class="line"><span class="comment"># 追加到开头</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;模块所在位置目录&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="重新导入模块"><a href="#重新导入模块" class="headerlink" title="重新导入模块"></a>重新导入模块</h2><p>在终端运行时,模块被导入后,<code>import 模块</code>不能重新导入模块,重新导入需要使用reload重新加载模块代码创建模块对象</p><p>解决方法:</p><p>使用reload()方法重新加载模块:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> reload</span><br><span class="line"><span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line">reload(test)</span><br><span class="line">test.test()</span><br></pre></td></tr></table></figure><h2 id="from…import-的私有化问题"><a href="#from…import-的私有化问题" class="headerlink" title="from…import 的私有化问题"></a>from…import 的私有化问题</h2><ul><li>私有化: 防止模块中的一些变量被其他模块导入,使用私有化解决</li><li>前提:必须使用‘from … import  *’</li><li>用法:在模块中把变量前加入下划线<code>_变量名</code></li><li>注意:使用其他方式导入模块私有化将无效</li></ul><h2 id="import和from…import-的区别"><a href="#import和from…import-的区别" class="headerlink" title="import和from…import 的区别"></a>import和from…import 的区别</h2><p>区别:</p><ul><li>写法:<ul><li>import 模块名.方法</li><li>from … import * 方法</li></ul></li><li>底层区别:<ul><li>import 直接引用了原模块模方法</li><li>from .. import 拷贝原模块的方法</li></ul></li></ul><h1 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h1><p>&#x3D;&#x3D;拆包&#x3D;&#x3D;:对于函数中的多个返回数据,去掉元组,列表或者字典直接获取里面数据的过程</p><ul><li><p>可变参数<code>*args **kwargs</code>默认会封包过程</p></li><li><p>如果想要这种单数继续传递给下一个函数,传递应用(*args,**kwargs)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @date     : 2022/11/9 19:36</span></span><br><span class="line"><span class="comment"># @author   : hahazhong</span></span><br><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 定义两个函数func01 func02 ,在func02中调用func01,func02有可变参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func01</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------func01-------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func03</span>(<span class="params">a, d, e, b=<span class="number">0</span>, c=<span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------func03------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func02</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------func02-------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">    func01(*args, **kwargs)</span><br><span class="line">    func03(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func02(<span class="number">1</span>, <span class="number">3</span>, c=<span class="number">999</span>, b=<span class="number">77</span>, e=<span class="number">55</span>)</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="单继承中的super"><a href="#单继承中的super" class="headerlink" title="单继承中的super()"></a>单继承中的super()</h2><p>super()使用的时候,传递参数的时候,swlf不用传递</p><p>super()调用顺序,按照mro顺序完成</p><blockquote><p>当在类中使用super()在mro列表中找到当前类的下一个元素,调用该元素的方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @date     : 2022/11/9 20:24</span></span><br><span class="line"><span class="comment"># @author   : hahazhong</span></span><br><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 理解单继承中的super()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span></span>):</span><br><span class="line">        self.surname = name[<span class="number">0</span>]</span><br><span class="line">        self.name = name[<span class="number">1</span>:]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Parent调用结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;son调用完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(<span class="title class_ inherited__">Son</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, sex</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.sex = sex</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson调用完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    zhangsan = Grandson(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;姓:&#x27;</span>, zhangsan.surname)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;名:&#x27;</span>, zhangsan.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;年龄:&#x27;</span>, zhangsan.age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;性别:&#x27;</span>, zhangsan.sex)</span><br></pre></td></tr></table></figure><h2 id="多继承以及MRO顺序"><a href="#多继承以及MRO顺序" class="headerlink" title="多继承以及MRO顺序"></a>多继承以及MRO顺序</h2><p>在子类初始化的时候需要手动调用父类的初始化方法进行父类的属性构造,不然不能使用提供的属性.</p><p>&#x3D;&#x3D;多继承&#x3D;&#x3D;:一个子类同时继承多个父类,又称为菱形继承、钻石继承</p><ul><li>多继承中super()执行顺序,严格执行MRO顺序</li></ul><p>查看MRO顺序表:</p><ul><li>类名.mro()</li><li><code>类名.__mro__</code></li></ul><p>MRO顺序：</p><ul><li>保证了多继承情况每个类只出现一次</li><li><code>super().__init__</code>相对于<code>类名.__init__</code>在单继承上用法基本无差</li><li>但是在多继承上有区别,super()方法可以保证每个父类只会执行一次,而实用类名的方法会导致方法执行多次</li><li>多继承时,使用super方法对父类传参数,应该是由于python的算法导致原因,必须把参数全部传递,否则会报错</li><li>多继承时,相对于使用<code>类名.__init__</code>方法要把每个父类全部写一遍,而使用super()方法,只需要写一句话便执行类全部父类的方法,这也是为何多继承需要全部传参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @author   : hahazhong</span></span><br><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 在子类初始化的时候需要手动调用父类的初始化方法进行父类的属性构造,不然不能使用提供的属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 未使用super()</span></span><br><span class="line"><span class="comment"># class Parent(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, name: str):</span></span><br><span class="line"><span class="comment">#         self.surname = name[0]</span></span><br><span class="line"><span class="comment">#         self.name = name[1:]</span></span><br><span class="line"><span class="comment">#         print(&#x27;Parent调用结束&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># class Son1(Parent):</span></span><br><span class="line"><span class="comment">#     def __init__(self, name, age):</span></span><br><span class="line"><span class="comment">#         # super().__init__(name)</span></span><br><span class="line"><span class="comment">#         Parent.__init__(self, name)</span></span><br><span class="line"><span class="comment">#         self.age = age</span></span><br><span class="line"><span class="comment">#         print(&#x27;son1调用完毕&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># class Son2(Parent):</span></span><br><span class="line"><span class="comment">#     def __init__(self, name, sex):</span></span><br><span class="line"><span class="comment">#         # super().__init__(name)</span></span><br><span class="line"><span class="comment">#         Parent.__init__(self, name)</span></span><br><span class="line"><span class="comment">#         self.sex = sex</span></span><br><span class="line"><span class="comment">#         print(&#x27;son2调用完毕&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># class Grandson(Son1, Son2):</span></span><br><span class="line"><span class="comment">#     def __init__(self, name, age, sex):</span></span><br><span class="line"><span class="comment">#         Son1.__init__(self, name, age)  # 单独调用Son1父类的初始化方法</span></span><br><span class="line"><span class="comment">#         Son2.__init__(self, name, sex)</span></span><br><span class="line"><span class="comment">#         print(&#x27;Grandson调用完毕&#x27;)</span></span><br><span class="line"><span class="comment"># 会发现father的__init__会被调用两次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用super()改进</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span></span>):</span><br><span class="line">        self.surname = name[<span class="number">0</span>]</span><br><span class="line">        self.name = name[<span class="number">1</span>:]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Parent调用结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;son1调用完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, sex, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)</span><br><span class="line">        self.sex = sex</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;son2调用完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(Son1, Son2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, sex</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age, sex)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson调用完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    zhangsan = Grandson(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;姓:&#x27;</span>, zhangsan.surname)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;名:&#x27;</span>, zhangsan.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;年龄:&#x27;</span>, zhangsan.age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;性别:&#x27;</span>, zhangsan.sex)</span><br><span class="line">    <span class="comment"># 查看mro顺序</span></span><br><span class="line">    <span class="built_in">print</span>(Grandson.mro())</span><br></pre></td></tr></table></figure><h1 id="property装饰方法"><a href="#property装饰方法" class="headerlink" title="property装饰方法"></a>property装饰方法</h1><h2 id="property基本使用"><a href="#property基本使用" class="headerlink" title="property基本使用"></a>property基本使用</h2><p>好处:可以让我们通过<code>对象.方法</code>名调用方法</p><p>语法格式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xxx</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>案例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创健方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">foo = Foo(<span class="number">888</span>)</span><br><span class="line"><span class="comment"># 调用对象方法</span></span><br><span class="line"><span class="comment"># print(foo.prop())</span></span><br><span class="line"><span class="comment"># property像使用属性一样去使用方法</span></span><br><span class="line"><span class="built_in">print</span>(foo.prop)</span><br></pre></td></tr></table></figure><p>property属性定义和调用需要注意:</p><ul><li>定义时,在实例方法的基础上添加@property装饰器,并且仅有一个self参数</li><li>调用时无需括号</li></ul><h2 id="property其他方法"><a href="#property其他方法" class="headerlink" title="property其他方法"></a>property其他方法</h2><p>Python中的类有&#x3D;&#x3D;经典类&#x3D;&#x3D;和&#x3D;&#x3D;新式类&#x3D;&#x3D;,新式类的属性比经典类的属性丰富。（如果类继承object，那么该类为新式类，Python3中默认所有类为新式类）</p><ol><li><p>经典类只有一种@property装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xxx</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>新式类具有三种@property装饰器</p><ul><li>@property</li><li>@xxx.setter:重新设置</li><li>@xxx.deleter:删除方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 1. 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.org_price = <span class="number">1000</span></span><br><span class="line">        self.discount = <span class="number">0.88</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 获取价格方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.org_price * self.discount</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 设置价格方法</span></span><br><span class="line"><span class="meta">    @price.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.org_price = val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 删除价格方法</span></span><br><span class="line"><span class="meta">    @price.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">goods = Goods()</span><br><span class="line"><span class="comment"># 打印现在价格</span></span><br><span class="line"><span class="built_in">print</span>(goods.price)</span><br><span class="line"><span class="comment"># 将价格改为2000</span></span><br><span class="line">goods.price = <span class="number">2000</span></span><br><span class="line"><span class="built_in">print</span>(goods.price)</span><br><span class="line"><span class="comment"># 删除操作</span></span><br><span class="line"><span class="keyword">del</span> goods.price</span><br><span class="line"><span class="built_in">print</span>(goods.price)</span><br></pre></td></tr></table></figure></li></ol><h2 id="property作为类属性"><a href="#property作为类属性" class="headerlink" title="property作为类属性"></a>property作为类属性</h2><p>当使用类属性的方式创建property属性,&#x3D;&#x3D;经典类&#x3D;&#x3D;和&#x3D;&#x3D;新式类&#x3D;&#x3D;无区别</p><p>案例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;铁汁&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># property对象</span></span><br><span class="line">    <span class="comment"># property(参数1,参数2,参数3,参数4)</span></span><br><span class="line">    <span class="comment"># 第一个参数,当我们foo.Bar自动调用第一个参数方法</span></span><br><span class="line">    <span class="comment"># 第二个参数,当foo.Bar=100时自动调用第二个参数方法</span></span><br><span class="line">    <span class="comment"># 第三个参数,当del foo.Bar时自动调用第三个参数方法</span></span><br><span class="line">    <span class="comment"># 第四个参数是字符串, 调用`foo.Bar.__doc__`, 自动调用第四个参数方法,此参数是该属性的描述信息</span></span><br><span class="line">    Bar = <span class="built_in">property</span>(get_bar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">foo = Foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过property获取属性</span></span><br><span class="line"><span class="built_in">print</span>(foo.Bar)</span><br></pre></td></tr></table></figure><p>property方法中有四个参数:</p><ul><li>第一个参数为方法名,调用<code>对象.属性</code>自动触发执行方法</li><li>第二个参数是方法名,调用<code>属性.xxx</code>时自动触发执行方法</li><li>第三个参数是方法名,调用<code>del 对象.属性</code>是自动触发执行方法</li><li>第四个参数是字符串,调用<code>类名.属性.__doc__</code>,此参数是该属性的描述信息</li></ul><p>案例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 1. 初始化方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._Bar</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.org_price = <span class="number">1000</span></span><br><span class="line">        self.discount = <span class="number">0.88</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 获取价格方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.org_price * self.discount</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 设置价格方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.org_price = val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 删除价格方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    Bar = <span class="built_in">property</span>(get_price, set_price, del_price, <span class="string">&#x27;Bar是一个property对象&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建对象</span></span><br><span class="line">    goods = Goods()</span><br><span class="line">    <span class="comment"># 获取价格</span></span><br><span class="line">    <span class="comment"># goods.Bar == goods.get_price()</span></span><br><span class="line">    <span class="built_in">print</span>(goods.Bar)</span><br><span class="line">    <span class="comment"># 重新设置价格</span></span><br><span class="line">    <span class="comment"># &#x27;goods.Bar = 2000&#x27; == good.set_price(2000)</span></span><br><span class="line">    goods.Bar = <span class="number">2000</span></span><br><span class="line">    <span class="built_in">print</span>(goods.Bar)</span><br><span class="line">    <span class="comment"># 删除价格</span></span><br><span class="line">    <span class="comment"># del goods.Bar == @del_price.deleter</span></span><br><span class="line">    <span class="keyword">del</span> goods.Bar</span><br><span class="line">    <span class="comment"># 获取对象描述</span></span><br><span class="line">    <span class="built_in">print</span>(Goods.Bar.__doc__)</span><br></pre></td></tr></table></figure><h1 id="魔术方法和属性"><a href="#魔术方法和属性" class="headerlink" title="魔术方法和属性"></a>魔术方法和属性</h1><p>无论人或者事物往往都有一些特殊含义的文字,Python的类属性也是如此,存在着一些具有特殊含义的属性</p><h3 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a><code>__doc__</code></h3><p>作用:表示类的描述信息</p><p>语法:</p><ul><li><p>获取类的描述信息:<code>类名.__doc__</code></p></li><li><p>获取对象的方法描述信息:<code>对象.方法.__doc__</code></p></li></ul><h3 id="moudle"><a href="#moudle" class="headerlink" title="__moudle__"></a><code>__moudle__</code></h3><p>作用: 获取当前模块</p><p>语法: <code>对象.__moudle__</code></p><h3 id="class"><a href="#class" class="headerlink" title="__class__"></a><code>__class__</code></h3><p>作用:获取当前对象所属类</p><p>语法: <code>对象.__class__</code></p><h3 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h3><p>作用: 初始化方法,通过类创建对象时,自动触发执行</p><h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><p>作用:删除对象会执行对象的__del__方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个商品类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化方法,通过类创建对象时,自动触发执行</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        self.original_price = num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置价格的方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;_____正在执行_____&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类的描述信息</span></span><br><span class="line"><span class="comment"># 类名.__doc__</span></span><br><span class="line"><span class="built_in">print</span>(Goods.__doc__)</span><br><span class="line"><span class="comment"># 对象方法的描述</span></span><br><span class="line">goods = Goods(<span class="number">55</span>)</span><br><span class="line"><span class="comment"># 对象.方法.__doc__</span></span><br><span class="line"><span class="built_in">print</span>(goods.set_price.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前模块</span></span><br><span class="line"><span class="built_in">print</span>(goods.__module__)</span><br><span class="line"><span class="comment"># 获取当前对象所属类</span></span><br><span class="line"><span class="built_in">print</span>(goods.__class__)</span><br><span class="line"><span class="comment"># 删除对象会执行对象的__del__方法</span></span><br><span class="line"><span class="keyword">del</span> goods</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>作用: 对象后面加括号,出发执行</p><p>注意:<code>__init__</code>方法执行是由创建对象触发的,即:<code>对象=类名()</code>;而<code>__call__</code>方法执行是由对象加括号触发的,即<code>对象()</code>或者<code>类()()</code></p><h3 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h3><p>作用: 类或者对象的所有属性,类的实例属性属于对象,类中的类属性和方法属于类</p><h3 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h3><p>作用: 如果一个类重定义<code>__str__</code>方法,那么在打印对象时,默认输出该方法的返回值</p><h3 id="getitem-96-96-setitem-delitem-96"><a href="#getitem-96-96-setitem-delitem-96" class="headerlink" title="__getitem__,&#96;&#96;setitem,delitem&#96;"></a><code>__getitem__</code>,&#96;&#96;<strong>setitem</strong><code>,</code><strong>delitem</strong>&#96;</h3><p>作用: 用于索引操作,如字典.以上分别表示获取、设置、删除数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个商品类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    color = <span class="string">&#x27;白色&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化方法,通过类创建对象时,自动触发执行</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.price = <span class="number">100</span></span><br><span class="line">        self.discount = <span class="number">0.88</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置价格的方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__call__方法被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;这是一个寂寞的对象&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;_____del正在执行_____&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;key==&#x27;</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;要删除key&#x27;</span>, key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">goods = Goods()</span><br><span class="line"><span class="comment"># 对象名() 会去调用对象的__call__()方法</span></span><br><span class="line">goods()</span><br><span class="line"><span class="comment"># print打印对象的时候,默认输出&lt;__main__.Goods object at 0x00000222B12D3520&gt;</span></span><br><span class="line"><span class="built_in">print</span>(goods)</span><br><span class="line"><span class="comment"># 通过__dict__获取对象信息</span></span><br><span class="line"><span class="built_in">print</span>(goods.__dict__)</span><br><span class="line"><span class="comment"># 通过__dict__获取类属性</span></span><br><span class="line"><span class="built_in">print</span>(Goods.__dict__)</span><br><span class="line"><span class="comment"># 调用__getitem__方法</span></span><br><span class="line">goods[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="comment"># 调用__setitem__方法</span></span><br><span class="line">goods[<span class="string">&#x27;b&#x27;</span>] = <span class="number">88</span></span><br><span class="line"><span class="comment"># 调用__setitem__方法</span></span><br><span class="line"><span class="keyword">del</span> goods[<span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure><h1 id="with管理上下文"><a href="#with管理上下文" class="headerlink" title="with管理上下文"></a>with管理上下文</h1><p>上下文：以witn open来说，打开文件在上，关闭文件在下</p><p>上下文管理器本质就是支持with操作。</p><p>任何实现了<code>__enter__()</code>和<code>__exit__()</code>方法的对象都可称之为上下文管理器,上下文管理器对象可以使用with关键字。</p><p>自定义文件管理器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFile</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_name, file_model</span>):</span><br><span class="line">        self.file_name = file_name</span><br><span class="line">        self.file_model = file_model</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __enter__() 上文方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 打开文件</span></span><br><span class="line">        self.file = <span class="built_in">open</span>(file=self.file_name, mode=self.file_model)</span><br><span class="line">        <span class="comment"># 返回打开的文件资源</span></span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __exit__() 下文方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="comment"># 关闭文件资源</span></span><br><span class="line">        self.file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> MyFile(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="comment"># file_data = file.read()</span></span><br><span class="line">        <span class="comment"># print(file_data)</span></span><br><span class="line">        h = <span class="string">&#x27;lagagagaga&#x27;</span></span><br><span class="line">        file.write(h)</span><br></pre></td></tr></table></figure><h2 id="装饰器方法"><a href="#装饰器方法" class="headerlink" title="装饰器方法"></a>装饰器方法</h2><p>Python还提供了一个contextmannager的装饰器，进一步简化了上下文管理器的实现方式。通过yield将函数分割成两部分，yeild之前的语句在<code>__enter__</code>方法中执行,yeild之后的语句在<code>__exit__</code>方法中执行,紧跟在yeild后面的值是函数返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行装饰</span></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="comment"># 定义函数,参数有文件地址,文件打开模式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myopen</span>(<span class="params">file_name, file_model</span>):</span><br><span class="line">    <span class="comment"># 打开文件</span></span><br><span class="line">    file = <span class="built_in">open</span>(file_name, file_model, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 返回资源</span></span><br><span class="line">    <span class="keyword">yield</span> file</span><br><span class="line">    <span class="comment"># 下文</span></span><br><span class="line">    <span class="comment"># 关闭资源</span></span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> myopen(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file_data = file.read()</span><br><span class="line">    <span class="built_in">print</span>(file_data)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GIL全局解释锁&quot;&gt;&lt;a href=&quot;#GIL全局解释锁&quot; class=&quot;headerlink&quot; title=&quot;GIL全局解释锁&quot;&gt;&lt;/a&gt;GIL全局解释锁&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;GIL锁:Global Interpreter Lock,又称为全局解释锁。&lt;/p&gt;
&lt;p&gt;任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。GIL锁实际上把所有线程的执行代码都给上了锁。所以，多线程在Python中智能交替执行，即使100个线程跑在100核CPU上也只能用到一核。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="高级语法" scheme="http://example.com/tags/%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（五）-- 装饰器</title>
    <link href="http://example.com/2022/10/14/Python%E8%BF%9B%E9%98%B6(%E4%BA%94)%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://example.com/2022/10/14/Python%E8%BF%9B%E9%98%B6(%E4%BA%94)%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2022-10-14T13:23:31.000Z</published>
    <updated>2022-11-17T13:41:09.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包概念"><a href="#闭包概念" class="headerlink" title="闭包概念"></a>闭包概念</h3><p>闭包是函数式编程的重要语法结构,Python支持这一特性</p><p>在一个外函数中定义（嵌套）了一个内函数,内函数中运用了外函数的临时变量,并且外函数的返回值是内函数的引用,这样构成了闭包。</p><span id="more"></span>  <h3 id="构成条件"><a href="#构成条件" class="headerlink" title="构成条件"></a>构成条件</h3><ol><li>必须有一个内嵌函数（函数里定义函数）——这对应函数之间的嵌套</li><li>内嵌函数必须引用一个定义在闭合范围内（外部函数）的变量——内部函数引用外部变量</li><li>外部函数必须返回内嵌函数——必须返回内部函数</li></ol><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @date     : 2022/10/21 16:44</span></span><br><span class="line"><span class="comment"># @author   : hahazhong</span></span><br><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 实现一个简单的闭包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1.function_out---------------num=&#x27;</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>(<span class="params">num_in</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;2.function_in---------------num=&#x27;</span>, num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;3.function_in---------------num_in=&#x27;</span>, num_in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># function_out(10)</span></span><br><span class="line"><span class="comment"># 调用外层函数,获取内层函数地址,保存到ret变量中</span></span><br><span class="line">ret = function_out(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用里层函数</span></span><br><span class="line">ret(<span class="number">66</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># 1.function_out---------------num= 100</span></span><br><span class="line"><span class="comment"># 2.function_in---------------num= 100</span></span><br><span class="line"><span class="comment"># 3.function_in---------------num_in= 66</span></span><br></pre></td></tr></table></figure><h3 id="闭包中的变量问题"><a href="#闭包中的变量问题" class="headerlink" title="闭包中的变量问题"></a>闭包中的变量问题</h3><p>问题：内层定义了和外层同名的变量</p><p>报错：<code>UnboundLocalError: local variable &#39;num&#39; referenced before assignment</code></p><p>解决办法:如果在内层定义了和外层同名的变量,二使用外部变量,使用nonlocal关键字进行约束,nonlocal表示用内部定义变量而使用外部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @date     : 2022/10/21 17:01</span></span><br><span class="line"><span class="comment"># @author   : hahazhong</span></span><br><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 了解闭包变量问题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1.function_out---------------num=&#x27;</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">        <span class="comment"># 错误原因:编译器认为内层函数已经定义了num变量,优先使用内部变量</span></span><br><span class="line">        <span class="comment"># 如果在内层定义了和外层同名的变量,二使用外部变量</span></span><br><span class="line">        <span class="comment"># nonlocal 表示用内部定义变量而使用外部变量</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;2.function_in---------------num=&#x27;</span>, num)</span><br><span class="line">        <span class="comment"># 内部自定义变量</span></span><br><span class="line">        num = <span class="number">99</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># function_out(10)</span></span><br><span class="line"><span class="comment"># 调用外层函数,获取内层函数地址,保存到ret变量中</span></span><br><span class="line">ret = function_out(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用里层函数</span></span><br><span class="line">ret()</span><br></pre></td></tr></table></figure><h2 id="装饰器入门"><a href="#装饰器入门" class="headerlink" title="装饰器入门"></a>装饰器入门</h2><p>装饰器:&#x3D;&#x3D;在不改变函数代码前提下,给函数添加新的功能&#x3D;&#x3D;</p><h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提:"></a>使用前提:</h3><ol><li>存在闭包(用于扩展新功能)</li><li>待扩展的普通函数(目的就是不改变函数,还增加新的功能)</li></ol><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式:"></a>语法格式:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@闭包外层函数xxx    </span><span class="comment"># 此处作用使用xxx装饰函数,给其扩展功能</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><p>规定&#x3D;&#x3D;已经实现的功能代码不允许被修改,但可以扩展&#x3D;&#x3D;,即:</p><ul><li>封闭:已经实现的功能代码块</li><li>开放:对扩展开放</li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @author   : hahazhong</span></span><br><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 给login()增加验证功能,不能修改原函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----开始验证-----&#x27;</span>)</span><br><span class="line">        func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function_out</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始登录&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过闭包调用外层函数</span></span><br><span class="line"><span class="comment"># login = function_out(login)</span></span><br><span class="line"><span class="comment"># 直接装饰器调用</span></span><br><span class="line">login()</span><br></pre></td></tr></table></figure><h2 id="装饰有参数的函数"><a href="#装饰有参数的函数" class="headerlink" title="装饰有参数的函数"></a>装饰有参数的函数</h2><ul><li><p>普通参数</p><p>注意:</p><ol><li>装饰器内层函数也需要对应参数</li><li>调用的函数也需要有对应参数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 装饰有固定参数的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>(<span class="params">num</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----开始验证-----,num=&#x27;</span>, num)</span><br><span class="line">        <span class="comment"># 执行待装饰函数</span></span><br><span class="line">        <span class="comment"># func(num)==login(num)</span></span><br><span class="line">        func(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function_out</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始登录 num=&#x27;</span>, num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰后login==function_in</span></span><br><span class="line">login(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>可变参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 装饰存在可变参数的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----开始验证-----,num=&#x27;</span>, )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;function_in args=&#x27;</span>, args)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;function_in kwargs=&#x27;</span>, kwargs)</span><br><span class="line">        <span class="comment"># 执行待装饰函数</span></span><br><span class="line">        <span class="comment"># func(num)==login(num)</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function_out</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始登录 num=&#x27;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始登录 args=&#x27;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始登录 kwargs=&#x27;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰后login==function_in</span></span><br><span class="line">login(<span class="number">10</span>, <span class="number">20</span>, num=<span class="number">66</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="装饰有返回值的函数"><a href="#装饰有返回值的函数" class="headerlink" title="装饰有返回值的函数"></a>装饰有返回值的函数</h2><ul><li>步骤<ol><li>带装饰参数必须有返回值(return)</li><li>闭包的内层函数改为返回内层函数</li></ol></li></ul><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>(<span class="params">num</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----开始验证-----&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function_out</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始登录&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">10</span>, num + <span class="number">88</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过闭包调用外层函数</span></span><br><span class="line"><span class="comment"># login = function_out(login)</span></span><br><span class="line"><span class="comment"># 直接装饰器调用</span></span><br><span class="line">result = login(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>通用版装饰器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @coding   : UTF-8</span></span><br><span class="line"><span class="comment"># @object   : 创建一个通用版装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 执行待装饰函数</span></span><br><span class="line">        <span class="comment"># 底层:func(num)==login(num)</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@function_out</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> kwargs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰后login==function_in</span></span><br><span class="line">result = login(<span class="number">10</span>, <span class="number">20</span>, num=<span class="number">66</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="在装饰器上设置外部参数"><a href="#在装饰器上设置外部参数" class="headerlink" title="在装饰器上设置外部参数"></a>在装饰器上设置外部参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">装饰器写法:</span></span><br><span class="line"><span class="string">1. 存在闭包</span></span><br><span class="line"><span class="string">2. 存在待修饰的函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="built_in">print</span>(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_out</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;---开始验证---&#x27;</span>)</span><br><span class="line">            func()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回内层函数引用</span></span><br><span class="line">        <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回装饰器引用</span></span><br><span class="line">    <span class="keyword">return</span> function_out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@test(<span class="params"><span class="string">&#x27;haha.py&#x27;</span></span>)</span></span><br><span class="line"><span class="comment"># 1.test(&#x27;haha.py&#x27;) --&gt;function_out 引用</span></span><br><span class="line"><span class="comment"># 2.@ 第一步的结果    --&gt; @function_out</span></span><br><span class="line"><span class="comment"># 下一步:login=function_out(login)</span></span><br><span class="line"><span class="comment"># @function_out</span></span><br><span class="line"><span class="comment"># 等同于login=function(login)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始登录&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">login()</span><br></pre></td></tr></table></figure><h2 id="多重装饰器"><a href="#多重装饰器" class="headerlink" title="多重装饰器"></a>多重装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b标签</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeBlod</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;b&gt;&#x27;</span> + func() + <span class="string">&#x27;&lt;/b&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># i标签</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeItalic</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">function_in</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;i&gt;&#x27;</span> + func() + <span class="string">&#x27;&lt;/i&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在hahazhong前加入b标签,装饰后为:&lt;b&gt;hahazhong-1&lt;/b&gt;</span></span><br><span class="line"><span class="meta">@makeBlod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hahazhong-1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makeItalic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hahazhong-2&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makeBlod</span></span><br><span class="line"><span class="meta">@makeItalic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test3</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hahazhong-3&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test())</span><br><span class="line"><span class="built_in">print</span>(test2())</span><br><span class="line"><span class="built_in">print</span>(test3())</span><br></pre></td></tr></table></figure><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>作用:使用类对装饰器进行调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;--init--方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在跳舞&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;--call--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">test = Test()</span><br><span class="line"><span class="comment"># test.dance()</span></span><br><span class="line"><span class="comment"># 当对象名()此时会去调用类中的__call__()方法</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>简单装饰器使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;--init--方法&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;--func--&#x27;</span>, func)</span><br><span class="line">        <span class="comment"># func 是待装饰函数的引用</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在跳舞&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;--开始验证--&#x27;</span>)</span><br><span class="line">        self.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;--call--&#x27;</span>, args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment"># login = Test(login)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">num, num2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始登录---&#x27;</span>, num, num2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">login(<span class="number">5</span>, num2=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h1&gt;&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;h3 id=&quot;闭包概念&quot;&gt;&lt;a href=&quot;#闭包概念&quot; class=&quot;headerlink&quot; title=&quot;闭包概念&quot;&gt;&lt;/a&gt;闭包概念&lt;/h3&gt;&lt;p&gt;闭包是函数式编程的重要语法结构,Python支持这一特性&lt;/p&gt;
&lt;p&gt;在一个外函数中定义（嵌套）了一个内函数,内函数中运用了外函数的临时变量,并且外函数的返回值是内函数的引用,这样构成了闭包。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="装饰器" scheme="http://example.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（四）-- 协程</title>
    <link href="http://example.com/2022/10/07/Python%E8%BF%9B%E9%98%B6(%E5%9B%9B)%E5%8D%8F%E7%A8%8B/"/>
    <id>http://example.com/2022/10/07/Python%E8%BF%9B%E9%98%B6(%E5%9B%9B)%E5%8D%8F%E7%A8%8B/</id>
    <published>2022-10-07T13:23:31.000Z</published>
    <updated>2022-11-17T13:40:02.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h1><p>遍历也叫迭代。</p><p>使用<code>isinstance()</code>检测对象是否可迭代。返回True表示可迭代，False表示不可迭代。</p><span id="more"></span>  <p>格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">isinstance</span>(检测对象,Iterable)</span><br></pre></td></tr></table></figure><p>注意:&#x3D;&#x3D;Python3.6版本以后导入Iterable需要从collections.abc中导入,不然会报错。&#x3D;&#x3D;</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可迭代对象通<code>_ _iter_ _</code>方法向我们提供一个迭代器，我们在迭代一个对象的时候，&#x3D;&#x3D;实际上就是先获取该对象的一个迭代器，然后通过迭代器依次获取对象中的每一个数据。&#x3D;&#x3D;</p><h3 id="iter-函数与next-函数"><a href="#iter-函数与next-函数" class="headerlink" title="iter()函数与next()函数"></a>iter()函数与next()函数</h3><ul><li><p>获取迭代器:<code>iter(可迭代对象)</code></p></li><li><p>获取可迭代对象的值:<code>next(迭代器)</code></p></li><li><p>迭代器特点:</p><ol><li>记录遍历的位置</li><li>提供下一个元素的值</li></ol></li><li><p>for循环本质:</p><ol><li>通过iter(可迭代对象)获取遍历对象的迭代器</li><li>通过next()获取下一个元素</li><li>捕获异常StopIteration</li></ol></li><li><p>自定义迭代器类</p><ol><li>必须含有<code>__iter__()</code></li><li>必须含有<code>__next__()</code></li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 一个可迭代对象提供一个迭代器</span></span><br><span class="line"><span class="string">2. 可迭代对象--&gt;iter(可迭代对象)--&gt;next(迭代器)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">65</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># 获取迭代器</span></span><br><span class="line">l1_iter = <span class="built_in">iter</span>(data_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据迭代器获取下一个值</span></span><br><span class="line">value = <span class="built_in">next</span>(l1_iter)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">value = <span class="built_in">next</span>(l1_iter)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">value = <span class="built_in">next</span>(l1_iter)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义迭代器类</span></span><br><span class="line"><span class="comment"># 1.必须含有__iter__()</span></span><br><span class="line"><span class="comment"># 2.必须含有__next__()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="迭代器应用-自定义列表"><a href="#迭代器应用-自定义列表" class="headerlink" title="迭代器应用:自定义列表"></a>迭代器应用:自定义列表</h2><ol><li>自定义Mylist类:</li></ol><ul><li>初始化方法</li><li><code>__iter__()</code>方法,对外提供迭代器</li><li><code>addItem()</code>方法添加数据</li></ul><ol start="2"><li>自定义迭代器:<ul><li>初始化方法</li><li>迭代器方法</li><li>获取下一个元素值方法</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. Mylist类</span></span><br><span class="line"><span class="string">   初始化方法</span></span><br><span class="line"><span class="string">   __iter__()方法,对外提供迭代器</span></span><br><span class="line"><span class="string">   addItem()方法添加数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义实例属性,保存数据</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建MyListIterator对象</span></span><br><span class="line">        mylist_iterator = MyListIterator(self.items)</span><br><span class="line">        <span class="keyword">return</span> mylist_iterator</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">additem</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.items.append(data)</span><br><span class="line">        <span class="comment"># print(self.items)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 自定义迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyListIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        <span class="comment"># 定义实例属性,保存传递过来的数据</span></span><br><span class="line">        self.items = items</span><br><span class="line">        <span class="comment"># 记录迭代器迭代器的位置</span></span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">   <span class="comment"># 迭代器方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 获取下一个元素值方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 判断当前下标是否越界</span></span><br><span class="line">        <span class="keyword">if</span> self.index &lt; <span class="built_in">len</span>(self.items):</span><br><span class="line">            <span class="comment">#   1)根据下标获取对应值</span></span><br><span class="line">            data = self.items[self.index]</span><br><span class="line">            <span class="comment">#   2)下标位置+1</span></span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="comment">#   3)返回下标对应的值</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="comment"># 如果越界抛出异常</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># raise主动抛出异常</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mylist = MyList()</span><br><span class="line">    mylist.additem(<span class="string">&#x27;西施&#x27;</span>)</span><br><span class="line">    mylist.additem(<span class="string">&#x27;貂蝉&#x27;</span>)</span><br><span class="line">    mylist.additem(<span class="string">&#x27;王昭君&#x27;</span>)</span><br><span class="line">    <span class="comment"># for 循环</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> mylist:</span><br><span class="line">        <span class="built_in">print</span>(val)</span><br><span class="line">    <span class="comment"># 迭代器方法</span></span><br><span class="line">    mylist_iter = <span class="built_in">iter</span>(mylist)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(mylist_iter))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(mylist_iter))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(mylist_iter))</span><br></pre></td></tr></table></figure><h2 id="斐波那契数列—迭代器"><a href="#斐波那契数列—迭代器" class="headerlink" title="斐波那契数列—迭代器"></a>斐波那契数列—迭代器</h2><p>自定义一个迭代器:</p><ul><li>含有<code>__itre__()</code></li><li>含有<code>__next__()</code></li></ul><p>思路:</p><p>创建a和b两个变量来保存值,然后使<code>a=b</code>,<code>b=a+b</code>来产生新的斐波那契数值,最终a的值就是斐波那契数列。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">自定义迭代器:</span></span><br><span class="line"><span class="string">1) 定义迭代器类</span></span><br><span class="line"><span class="string">2)含有__iter__()</span></span><br><span class="line"><span class="string">3)含有__next__()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">feibonaqi</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="comment"># 定义实例属性,保存生成个数</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义变量保存</span></span><br><span class="line">        self.a = <span class="number">1</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录下标位置</span></span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 判断列表是否超过生成的总列数</span></span><br><span class="line">        <span class="keyword">if</span> self.index &lt; self.num:</span><br><span class="line">            <span class="comment"># 保存a的值</span></span><br><span class="line">            data = self.a</span><br><span class="line">            <span class="comment"># 让a的值等于b,b的值等于a+b</span></span><br><span class="line"></span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">            <span class="comment"># 列数加一</span></span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="comment"># 超出范围报错</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建迭代器对象</span></span><br><span class="line">    fei = feibonaqi(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> fei:</span><br><span class="line">        <span class="built_in">print</span>(valve)</span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>概念：利用迭代器，在每次迭代数据是按照特定规律进行生成，在实现迭代器时，当前迭代状态需要我们自己记录，进而才能根据状态生成下一个数据。而生成器可以记录当前状态，并且配合<code>next()</code>函数进行迭代。&#x3D;&#x3D;生成器也是一类特殊的迭代器。&#x3D;&#x3D;</p><p>创建方式：</p><ul><li>生成器推导式</li><li>函数中使用<code>yelid</code></li></ul><p>代码实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">迭代器的作用是保存位置,返回下一个值</span></span><br><span class="line"><span class="string">next(生成器)也应该能得到下一个值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">data_list = [x - <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>)]</span><br><span class="line"><span class="comment"># 可迭代对象必须通过iter()函数去生成迭代器才可进行next迭代</span></span><br><span class="line">iter_data = <span class="built_in">iter</span>(data_list)</span><br><span class="line">data = <span class="built_in">next</span>(iter_data)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器创建1:生成器推导式</span></span><br><span class="line">data_list2 = (x - <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>))</span><br><span class="line"><span class="comment"># 生成器本身就是迭代器</span></span><br><span class="line">data = <span class="built_in">next</span>(data_list2)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器创建2: yield</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">656</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = test()</span><br><span class="line"><span class="built_in">print</span>(data)  <span class="comment"># 输出结果为&lt;generator object test at 0x0000021627BE20A0&gt;</span></span><br><span class="line">val = <span class="built_in">next</span>(data)</span><br><span class="line"><span class="built_in">print</span>(val)  <span class="comment"># 输出结果为[1, 2, 3, 4, 656, 8]</span></span><br></pre></td></tr></table></figure><h2 id="斐波那契数列—生成器"><a href="#斐波那契数列—生成器" class="headerlink" title="斐波那契数列—生成器"></a>斐波那契数列—生成器</h2><p>创建一个生成器实现斐波那契数列:</p><ol><li>定义变量保存第一组和第二组的值</li><li>定义变量保存当前生成位置</li><li>循环生成数据</li><li>保存a的值</li><li>修改a和b的值(a&#x3D;b,b&#x3D;a+b)</li><li>返回a的值</li></ol><p>代码实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成器实现斐波那契数列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">feibo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 1. 定义变量保存第一组和第二组的值</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 2. 定义变量保存当前生成位置</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 3. 循环生成数据</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; n:</span><br><span class="line">        <span class="comment"># 4. 保存a的值</span></span><br><span class="line">        data = a</span><br><span class="line">        <span class="comment"># 5. 修改a和b的值(a=b,b=a+b)</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 6. 返回a的值</span></span><br><span class="line">        <span class="keyword">yield</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fi_data = feibo(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in fi_data:</span></span><br><span class="line">    <span class="comment">#    print(i)</span></span><br><span class="line">    value = <span class="built_in">next</span>(fi_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第1次&#x27;</span>,value)</span><br><span class="line">     value = <span class="built_in">next</span>(fi_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第2次&#x27;</span>,value)</span><br><span class="line">     value = <span class="built_in">next</span>(fi_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第3次&#x27;</span>,value)</span><br><span class="line">     value = <span class="built_in">next</span>(fi_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第次&#x27;</span>,value)</span><br></pre></td></tr></table></figure><p> 通过代码发现yiled作用:</p><ol><li>充当return返回</li><li>保存程序的运行状态,并且暂停程序执行  </li><li>当next()的时候,可以唤醒程序从yield位置继续向下执行</li></ol><h2 id="生成器使用注意"><a href="#生成器使用注意" class="headerlink" title="生成器使用注意"></a>生成器使用注意</h2><ul><li>return的作用：可以结束生成器的运行。</li><li>send()作用：生成器.send(传递给生成器的值),停止生成器。</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程又称为微线程，纤程。&#x3D;&#x3D;协程就是可以暂停执行的函数&#x3D;&#x3D;。线程和进程的操作由程序触发系统接口，最后的执行者是系统；协程的操作是程序员。</p><ul><li><p>协程的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换需要耗时。&#x3D;&#x3D;协程只使用一个线程（单线程），在一个线程中规定某个代码块执行顺序。&#x3D;&#x3D;</p></li><li><p>协程适用场景：当程序中存在大量不需要CUP的操作时，适用于协程。</p></li></ul><p>协程和线程差异：实现多任务时，线程切换从系统层面远不止保存和恢复CPU上下文这么简单。系统为了程序的高效性每个线程都有自己的缓存数据，操作系统还会帮你做这些数据的恢复系统，所以线程非常耗性能。但是协程知识单纯的操作CPU的上下文，所以一秒钟切换上百万次系统都扛得住。</p><p>利用<code>yield</code>创建协程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;work1---------&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;work2---------&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取生成器,并且通过next运行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    work1 = work1()</span><br><span class="line">    work2 = work2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">next</span>(work1)</span><br><span class="line">        <span class="built_in">next</span>(work2)</span><br></pre></td></tr></table></figure><h2 id="Greenlet实现协程"><a href="#Greenlet实现协程" class="headerlink" title="Greenlet实现协程"></a>Greenlet实现协程</h2><p>​     Greenlet可以提供可自行调度的‘微线程’,即协程。在greenlet中<code>target.switch(value)</code>可以切换到指定的协程,greenlet用switch来表示协程的切换,从一个协程切换到另一个协程需要显式指定。</p><p>greenlet实现协程:</p><ol><li>导入模块</li><li>创建任务</li><li>创建greenlet对象</li><li>手动switch对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">greenlet实现协程:</span></span><br><span class="line"><span class="string">1.导入模块</span></span><br><span class="line"><span class="string">2.创建任务</span></span><br><span class="line"><span class="string">3.创建greenlet对象</span></span><br><span class="line"><span class="string">4.手动switch对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 1.导入模块</span></span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;work1---------&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="comment"># 切换到第二个任务</span></span><br><span class="line">        g2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;work2---------&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="comment"># 切换到work1</span></span><br><span class="line">        g1.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建greenlet对象</span></span><br><span class="line">    g1 = greenlet(work1)</span><br><span class="line">    g2 = greenlet(work2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行work1</span></span><br><span class="line">    <span class="comment"># 手动switch对象</span></span><br><span class="line">    g1.switch()</span><br></pre></td></tr></table></figure><h2 id="Gevent实现协程"><a href="#Gevent实现协程" class="headerlink" title="Gevent实现协程"></a>Gevent实现协程</h2><p>Gevent原理就是greenlet遇到IO操作时,就会自动切换到其他greenlet,等IO操作完成再在适当时刻切换回来继续执行。</p><p>&#x3D;&#x3D;优点&#x3D;&#x3D;：自动识别IO耗时操作,自动切换到其他任务</p><p>&#x3D;&#x3D;步骤：&#x3D;&#x3D;</p><ul><li><p>导入模块</p></li><li><p>指派任务</p></li><li><p>让主线程等待协程执行完毕</p></li></ul><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 导入模块</span></span><br><span class="line"><span class="string">2. 指派任务</span></span><br><span class="line"><span class="string">3. 自动识别IO耗时操作,自动切换到其他任务</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># gevent.getcurrent()查看当前执行任务的协程</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;work1---------&#x27;</span>, gevent.getcurrent())</span><br><span class="line">        <span class="comment"># 默认情况下gevent无法识别到time.sleep为耗时操作,</span></span><br><span class="line">        <span class="comment"># 1.需要使用gevent.sleep()</span></span><br><span class="line">        <span class="comment"># 2.给gevent打补丁(让gevent识别time.sleep)</span></span><br><span class="line">        <span class="comment"># 打补丁:在不修改源代码情况下,微程序增加新功能</span></span><br><span class="line">        <span class="comment"># 1. 导入模块monkey模块    from gevent import monkey</span></span><br><span class="line">        <span class="comment"># 2. 破解所有  monkey.patch_all()</span></span><br><span class="line">        time.sleep(<span class="number">0.4</span>)</span><br><span class="line">        <span class="comment"># gevent.sleep(2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;work2---------&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># gevent.sleep(6)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 指派任务</span></span><br><span class="line">    <span class="comment"># gevent.spawn(函数名,参数1,参数2)</span></span><br><span class="line">    g1 = gevent.spawn(work1)</span><br><span class="line">    g2 = gevent.spawn(work2)</span><br><span class="line">    <span class="comment"># 让主线程等待协程执行完毕</span></span><br><span class="line">    g1.join()</span><br><span class="line">    <span class="comment"># g2.join()</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;： 默认情况下gevent无法识别到time.sleep为耗时操作，解决方法：</p><ol><li>需要使用gevent.sleep()</li><li>给gevent打补丁(让gevent识别time.sleep)<br>打补丁:在不修改源代码情况下,微程序增加新功能<ol><li>导入模块monkey模块    from gevent import monkey</li><li>破解所有  monkey.patch_all</li></ol></li></ol><p>猴子补丁作用：</p><ol><li>在运行时替换方法、属性等</li><li>不修改第三方代码情况下增加原来不支持的功能</li><li>在运行时为内存中的对象增加patch而不是磁盘的源代码中执行</li></ol><h2 id="进程线程协程区别"><a href="#进程线程协程区别" class="headerlink" title="进程线程协程区别"></a>进程线程协程区别</h2><ol><li><p>进程</p><p>进程是具有一定独立功能的程序关与某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的基本单位.每个进程有自己的独立内存空间,不同进程通过进程间通信来通信.由于进程比较重量,占独立的内存,所以上下文间的切换开销比较大,但相对比稳定安全.</p></li><li><p>线程</p><p>线城是进程的一个实体,是CPU调度和分配的基本单位,是比进程更小的能独立运行的和基本单位.线程自己基本上不拥有系统资源</p><p>,只拥有一点在运行时必不可少的资源,但是可以与同属一个进程的其他线程共享所拥有的全部资源.线程间通信主要通过共享内容,上下文切换很快,资源开销少,但相对于进程不稳定容易丢失数据.</p></li><li><p>协程</p><p>协程是一种用户态的轻量级线程,协程的调度可以完全由用户控制,协程有自己的寄存器上下文和栈.协程调度切换时,将寄存器上下文和栈保存到其他地方,再切回来的时候,恢复先前保存的寄存器上下文和栈,基本没有内核切换开销,可以不加锁访问全局变量,所以上下文切换非常快.</p></li><li><p>应用场景</p><ul><li><p>多进程:密集CPU任务,充分使用多核CPU资源,用多进程。</p><p>缺陷：多进程间通信成本高，切换开销大</p></li><li><p>多线程：密集（I&#x2F;O任务使用多线程合适</p><p>缺陷：同一时间切片只能运行一个线程，不能做到高并行，但可以高并发</p></li><li><p>协程：当程序中存在大量不需要CPU的操作时，适用于协程</p><p>缺陷: 单线程执行,处理密集CPU任务是性能较低,处理网络I&#x2F;O想能较高</p></li></ul></li></ol><h2 id="并发下载器"><a href="#并发下载器" class="headerlink" title="并发下载器"></a>并发下载器</h2><p><code>genvent.joinall([协程对象])</code></p><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 定义下载路径</span></span><br><span class="line"><span class="string">2. 调用下载函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">文件下载函数:</span></span><br><span class="line"><span class="string">1. 打开url请求网络资源</span></span><br><span class="line"><span class="string">2. 在本地创建文件</span></span><br><span class="line"><span class="string">3. 读取网络资源数据</span></span><br><span class="line"><span class="string">4. 将资源写入本地数据</span></span><br><span class="line"><span class="string">5. 做异常捕获</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">url, filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 1. 打开url请求网络资源</span></span><br><span class="line">        res = urllib.request.urlopen(url)</span><br><span class="line">        <span class="comment"># 在本地创建文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            <span class="comment"># 3.读取网络资源数据</span></span><br><span class="line">            file_data = res.read()</span><br><span class="line">            <span class="comment"># 4.将资源写入本地数据</span></span><br><span class="line">            file.write(file_data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;filename&#125;</span>下载完成&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    img1 = <span class="string">&#x27;https://tenfei04.cfp.cn/creative/vcg/800/new/VCG41N1210205351.jpg&#x27;</span></span><br><span class="line">    img2 = <span class="string">&#x27;https://t7.baidu.com/it/u=4036010509,3445021118&amp;fm=193&amp;f=GIF&#x27;</span></span><br><span class="line">    img3 = <span class="string">&#x27;https://t7.baidu.com/it/u=963301259,1982396977&amp;fm=193&amp;f=GIF&#x27;</span></span><br><span class="line"></span><br><span class="line">    gevent.joinall([</span><br><span class="line">        gevent.spawn(download, img1, <span class="string">&#x27;1.jpg&#x27;</span>),</span><br><span class="line">        gevent.spawn(download, img2, <span class="string">&#x27;2.jpg&#x27;</span>),</span><br><span class="line">        gevent.spawn(download, img3, <span class="string">&#x27;3.jpg&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;可迭代对象&quot;&gt;&lt;a href=&quot;#可迭代对象&quot; class=&quot;headerlink&quot; title=&quot;可迭代对象&quot;&gt;&lt;/a&gt;可迭代对象&lt;/h1&gt;&lt;p&gt;遍历也叫迭代。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;isinstance()&lt;/code&gt;检测对象是否可迭代。返回True表示可迭代，False表示不可迭代。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="协程" scheme="http://example.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（三）-- 进程</title>
    <link href="http://example.com/2022/10/01/Python%E8%BF%9B%E9%98%B6(%E4%B8%89)%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2022/10/01/Python%E8%BF%9B%E9%98%B6(%E4%B8%89)%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-10-01T13:23:31.000Z</published>
    <updated>2022-11-17T13:50:03.875Z</updated>
    
    <content type="html"><![CDATA[<p>进程(Process)是资源分配的最小单位，也是线程的容器。</p><span id="more"></span><h1 id="进程以及状态"><a href="#进程以及状态" class="headerlink" title="进程以及状态"></a>进程以及状态</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程(Process)是资源分配的最小单位，也是线程的容器。</p><p>&#x3D;&#x3D;程序&#x3D;&#x3D;：也就是一个静态的软件。</p><p>&#x3D;&#x3D;进程&#x3D;&#x3D;：一个程序运行起来后，代码+用到的资源称为进程，是操作系统中分配资源的基本单元。</p><p>&#x3D;&#x3D;程序是固定不变的，而进程会根据运行需要，让操作系统分配资源的。&#x3D;&#x3D;</p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>任务数往往大于CPU核数，所以肯定会有一些任务在执行，另一部分在等待执行，所以有了不同的状态。</p><ul><li>就绪态：运行条件都已经满足，正在等待CPU执行。</li><li>执行态：CPU正在执行其功能</li><li>等待态：等待某些条件满足。</li></ul><h1 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h1><p>​<code>multiprocessing</code>模块是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。</p><h3 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h3><p>步骤：</p><ol><li>导入模块</li><li>通过模块提供的Process类创建进程</li><li>启动进程</li></ol><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在完成work1.......&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1. 导入模块</span></span><br><span class="line">    <span class="comment"># 2.通过模块提供的Process类创建进程</span></span><br><span class="line">    process_work1 = multiprocessing.Process(target=work1)</span><br><span class="line">    <span class="comment"># 3.启动进程</span></span><br><span class="line">    process_work1.start()</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Process&#x3D;&#x3D;语法结构：</p><p><code>Process([group[,target[,name[,args[,kwargs]]]]])</code></p><ul><li>&#x3D;&#x3D;target&#x3D;&#x3D;:传递函数的引用,这个子进程就执行这个函数的代码</li><li>&#x3D;&#x3D;args&#x3D;&#x3D;:给target指定的函数以元组的形式传参数</li><li>&#x3D;&#x3D;kwargs&#x3D;&#x3D;:给target指定的函数以字典的形式传参数</li><li>name:给进程设定名称</li><li>group:指定进程组</li></ul><p>Process创建的实例对象的常用方法:</p><ul><li>start():启动子进程</li><li>is_alive:判断子进程是否存活</li><li>join():是否等待子进程执行结束,或者等待多长时间</li><li>terminate():不管任务是否完成,立即终止子进程</li></ul><p>Process创建的实例对象的常用属性:</p><ul><li>name:当前进程的别名</li><li>pid:当前进程的pid(进程号)</li></ul><h1 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h1><ul><li><p>获取进程名称:</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> multiprocessing.current_process()</span><br><span class="line"><span class="number">2.</span> 创建子进程后</span><br><span class="line">子进程.name</span><br></pre></td></tr></table></figure></blockquote></li><li><p>获取进程编号:</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> multiprocessing.current_process().pid</span><br><span class="line"><span class="number">2.</span> 子进程.pid</span><br><span class="line"><span class="number">3.</span> 利用os模块os.getpid()</span><br></pre></td></tr></table></figure></blockquote></li><li><p>获取进程父id</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.getppid()</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>案例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1. 导入模块</span></span><br><span class="line"><span class="string">2. 通过模块提供的Process类创建进程</span></span><br><span class="line"><span class="string">3. 启动进程</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 获取进程信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;子进程信息:&#x27;</span>, multiprocessing.current_process())</span><br><span class="line">        <span class="comment"># 获取进程编号</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;进程id:&#x27;</span>, multiprocessing.current_process().pid)</span><br><span class="line">        <span class="comment"># 使用os模块</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;进程id:&#x27;</span>, os.getpid())</span><br><span class="line">        <span class="comment"># 获取进程父id</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;进程父id:&#x27;</span>, os.getppid())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在完成work1.......&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 主进程信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程信息:&#x27;</span>, multiprocessing.current_process())</span><br><span class="line">    <span class="comment"># 1. 导入模块</span></span><br><span class="line">    <span class="comment"># 2.通过模块提供的Process类创建进程</span></span><br><span class="line">    process_work1 = multiprocessing.Process(target=work1)</span><br><span class="line">    <span class="comment"># 3.启动进程</span></span><br><span class="line">    process_work1.start()</span><br><span class="line">    <span class="comment"># 获取process的信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;process_work1的全部信息:&#x27;</span>, process_work1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;process_work1的名称和编号:&#x27;</span>, process_work1.name, process_work1.pid)</span><br></pre></td></tr></table></figure><h1 id="进程参数和全局变量问题"><a href="#进程参数和全局变量问题" class="headerlink" title="进程参数和全局变量问题"></a>进程参数和全局变量问题</h1><ol><li><p>子进程参数传递与线程参数传递一样。</p></li><li><p>进程间不能共享全局变量。（子进程只是复制主进程变量使用，并不对原数据进行改变）</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------work1-------&#x27;</span>, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------work2-------&#x27;</span>, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    process1 = multiprocessing.Process(target=work1)</span><br><span class="line">    process2 = multiprocessing.Process(target=work2)</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    <span class="comment"># 主进程等待子进程结束</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------main-------&#x27;</span>, g_num)</span><br></pre></td></tr></table></figure></li></ol><h1 id="守护主进程"><a href="#守护主进程" class="headerlink" title="守护主进程"></a>守护主进程</h1><ul><li>&#x3D;&#x3D;进程守护&#x3D;&#x3D;：子进程和主线程的一种约定，主线程结束，子线程也结束。</li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 线程daemon属性</span></span><br><span class="line">process1 = multiprocessing.Process(target=work1, daemon=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#2. 子线程.daemon = True</span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p>结束子线程：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过terminate终止子线程</span></span><br><span class="line">process4.terminate()</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------work1-------&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------work2-------&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work3</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------work3-------&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work4</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------work4-------&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    <span class="comment"># 设置子线程process1守护主线程</span></span><br><span class="line">    process1 = multiprocessing.Process(target=work1, daemon=<span class="literal">True</span>)</span><br><span class="line">    process2 = multiprocessing.Process(target=work2)</span><br><span class="line">    process3 = multiprocessing.Process(target=work3)</span><br><span class="line">    process4 = multiprocessing.Process(target=work4)</span><br><span class="line">    <span class="comment"># 设置子线程process3守护主线程</span></span><br><span class="line">    process3.daemon = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process3.start()</span><br><span class="line">    process4.start()</span><br><span class="line">    <span class="comment"># 主进程等待子进程结束</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------main结束-------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    process4.terminate()</span><br><span class="line">    exit()</span><br></pre></td></tr></table></figure><p>上述案例中，进程1和进程3为守护进程，在主进程结束后随之结束。进程4在主线程结束后也通过<code>terminate</code>终止。只有进程2在主进程结束后还在运行。</p><h1 id="进程、线程对比"><a href="#进程、线程对比" class="headerlink" title="进程、线程对比"></a>进程、线程对比</h1><ol><li><p>功能：</p><ul><li>&#x3D;&#x3D;进程&#x3D;&#x3D;能够完成多任务，比如在一台电脑上能够同时运行多个QQ；</li><li>&#x3D;&#x3D;线程&#x3D;&#x3D;能够完成多任务，比如一个QQ中国的多个聊天窗口；</li></ul></li><li><p>使用区别</p><ul><li>&#x3D;&#x3D;进程是系统进行资源分配和调度的一个独立单位&#x3D;&#x3D;；</li><li>&#x3D;&#x3D;线程是进程的一个实体，是CPU调度和分配的基本单位&#x3D;&#x3D;，它是比进程更小的能独立运行的基本单位。线程自己基本不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可以与同属一个进程的其他线程共享进程拥有的全部资源。</li><li>一个程序至少有一个进程，一个进程至少有一个线程。</li><li>线程的划分尺度小于进程（资源比进程少），使得多线程程序并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而大大提高了程序的运行效率。</li><li>线程不能独立执行，必须依存在进程中。</li></ul><table><thead><tr><th>对比维度</th><th>多进程</th><th>多线程</th><th>总结</th><th></th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据共享复杂，需要用IPC；数据是分开的，同步简单</td><td>数据共享简单，同步复杂</td><td>各有优势</td><td></td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU利用率低。</td><td>占用内存少，切换简单，CPU利用率高</td><td>线程占优</td><td></td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>简单，速度很快</td><td>线程占优</td><td></td></tr><tr><td>可靠性</td><td>进程间不会互相影响</td><td>一个线程挂掉导致整个进程挂掉</td><td>进程占优</td><td></td></tr><tr><td>分布式</td><td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单。</td><td>适应于多核分布式</td><td>进程占优</td><td></td></tr></tbody></table><p>选择原则：</p><ul><li><p>需要频繁创建销毁的优先使用线程；（如：Web服务器）</p></li><li><p>线程切换速度快，所以在需要大量计算，切换频繁时用线程（如图像处理、算法处理）</p></li><li><p>因为对CPU系统的效率使用上线程更占优，多机分布用进程，多核分布用线程</p></li><li><p>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好</p></li><li><p>都满足需求时，熟悉哪个用哪个。</p></li></ul></li></ol><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>Process之间有时需要通信,操作系统提供了很多机制来实现进程通信。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>使用multiprocessing模块中的Queue实现多进程通信。Queue本身就是一个消息队列程序。</p><p>创建：</p><ul><li><p>&#x3D;&#x3D;导入模块&#x3D;&#x3D;：<code>multiprocessing</code></p></li><li><p>&#x3D;&#x3D;创建队列&#x3D;&#x3D;：<code>multiprocessing.Queue()</code></p></li><li><p>&#x3D;&#x3D;放值&#x3D;&#x3D;:——&gt;&#x3D;&#x3D;从队列尾部放入&#x3D;&#x3D;</p><p>可以放任意类型,长度范围内,放多后就会进入阻塞状态,等待有空闲卡槽时再放入)<br><code>queue.put(值)</code></p><p>当队列有空闲卡槽时才能放进去,没有报错</p><p><code>queue.put_nowait(值)</code></p></li><li><p>&#x3D;&#x3D;取值&#x3D;&#x3D;:——&gt;&#x3D;&#x3D;从队列头部取出&#x3D;&#x3D;</p><p>当队列为空时再取值会进入阻塞状态,等待传入新值再进行取值</p><p><code>a = queue.get() print(a)</code></p><p>当队列已空时不等待,直接报错</p><p><code>b = queue.get_nowait()</code></p><p><code>print(b)</code></p></li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">队列是multiprocessing模块的一个类</span></span><br><span class="line"><span class="string">1.创建队列</span></span><br><span class="line"><span class="string">2.放值</span></span><br><span class="line"><span class="string">3.取值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建队列</span></span><br><span class="line">queue = multiprocessing.Queue(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.放值(可以放任意类型,长度范围内,放多后就会进入阻塞状态,等待有空闲卡槽时再放入)</span></span><br><span class="line">queue.put(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 当队列有空闲卡槽时才能放进去,没有报错</span></span><br><span class="line">queue.put_nowait(<span class="number">22</span>)</span><br><span class="line"><span class="comment"># 3.取值</span></span><br><span class="line"><span class="comment"># 当队列为空时再取值会进入阻塞状态,等待传入新值再进行取值</span></span><br><span class="line">a = queue.get()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 当队列已空时不等待,直接报错</span></span><br><span class="line">b = queue.get_nowait()</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><h3 id="常见判断"><a href="#常见判断" class="headerlink" title="常见判断"></a>常见判断</h3><ol><li><p>判断是否已满–&gt;True已经满了,False未满</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">队列.full()</span><br></pre></td></tr></table></figure></li><li><p>判断是否为空–&gt;True已经空了,False未空</p></li></ol>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">队列.empty()</span><br></pre></td></tr></table></figure><ol start="3"><li>取出队列中的消息数量</li></ol>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">队列.qsize()</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 判断是否已满</span></span><br><span class="line"><span class="string">2. 判断是否为空</span></span><br><span class="line"><span class="string">3. 取出队列中的消息</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">queue = multiprocessing.Queue(<span class="number">3</span>)</span><br><span class="line">queue.put(<span class="number">1</span>)</span><br><span class="line">queue.put(<span class="number">2</span>)</span><br><span class="line">queue.put(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 取出队列中的消息</span></span><br><span class="line">num = queue.qsize()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;队列中有多少消息:&#x27;</span>, num)</span><br><span class="line"><span class="comment"># 填入3个值后再取出一个</span></span><br><span class="line">queue.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 判断是否已满 --&gt;True已经满了,False未满</span></span><br><span class="line">isFull = queue.full()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;isFull------&gt;是否满了&#x27;</span>, isFull)</span><br><span class="line"><span class="comment"># 2. 判断是否为空 --&gt;True已经空了,False未空</span></span><br><span class="line">isEmpty = queue.empty()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;isEmpty--&gt;是否为空&#x27;</span>, isEmpty)</span><br><span class="line"><span class="comment"># queue.get()</span></span><br><span class="line"><span class="comment"># queue.get()</span></span><br><span class="line"><span class="comment"># 3. 取出队列中的消息</span></span><br><span class="line">num = queue.qsize()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;队列中有多少消息:&#x27;</span>, num)</span><br></pre></td></tr></table></figure><h1 id="Queue实现进程间通信"><a href="#Queue实现进程间通信" class="headerlink" title="Queue实现进程间通信"></a>Queue实现进程间通信</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 思路:</span></span><br><span class="line"><span class="comment"># 1. 准备两个进程</span></span><br><span class="line"><span class="comment"># 2.准备队列,一个进程写入数据</span></span><br><span class="line"><span class="comment"># 3. 另一个进程读取数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.写入数据到队列的函数:</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_queue</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> queue.full():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;队列已满!!!&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        queue.put(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;写入数据:&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.读取数据到并显示的函数:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_queue</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> queue.empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;队列已空!!!&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        value = queue.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;读取到的数据:&#x27;</span>, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建队列</span></span><br><span class="line">    queue = multiprocessing.Queue(<span class="number">9</span>)</span><br><span class="line">    <span class="comment"># 创建进程</span></span><br><span class="line">    queue_w = multiprocessing.Process(target=write_queue, args=(queue,))</span><br><span class="line">    queue_r = multiprocessing.Process(target=read_queue, args=(queue,))</span><br><span class="line">    queue_w.start()</span><br><span class="line">    <span class="comment">#为了让queue_r读取到数据,可以通过join让queue_w执行结束后再读取</span></span><br><span class="line">    <span class="comment"># queue_w.join()</span></span><br><span class="line">    queue_r.start()</span><br></pre></td></tr></table></figure><h1 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h1><p>&#x3D;&#x3D;概述&#x3D;&#x3D;:当需要创建的子进程数量不多时,可以使用<code>multiprocessing</code>中的<code>Process</code>动态生成多个进程。如果创建进程数量巨大时，此时就可以用到multiprocessing提供的Pool方法。</p><p>​初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果进程池还没有满，就会创建一个新的进程来执行该请求；但如果进程数达到最大，该请求将会等待，直到池中有进程结束，才会用之前的进程来执行新任务。</p><h3 id="进程池实现效果"><a href="#进程池实现效果" class="headerlink" title="进程池实现效果"></a>进程池实现效果</h3><ul><li>同步方式：<code>Pool.apply</code></li><li>异步方式：<code>Pool.apply_async(copy_work)</code></li></ul><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p><code>multiprocessing.Pool</code>常用函数解析:</p><ul><li>&#x3D;&#x3D;apply()&#x3D;&#x3D;:进程池中进程以同步方式执行任务</li><li>&#x3D;&#x3D;apply_async(func[,args[,kwds]])&#x3D;&#x3D;: 使用费阻塞方式调用func</li></ul><p>代码实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;思路:</span></span><br><span class="line"><span class="string">1. 创建函数,用于模拟文件拷贝</span></span><br><span class="line"><span class="string">2.创建一个进程池</span></span><br><span class="line"><span class="string">3. 先用同步方式拷贝文件</span></span><br><span class="line"><span class="string">4. 异步拷贝文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建函数,用于模拟文件拷贝</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_work</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在拷贝文件------&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 2.创建一个进程池(最大放三个进程)</span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 3. 先用同步方式拷贝文件:pool.apply(函数名,(参数,))</span></span><br><span class="line">        <span class="comment"># pool.apply(copy_work)</span></span><br><span class="line">        <span class="comment"># 4. 异步拷贝文件</span></span><br><span class="line">        <span class="comment"># 注意:使用异步方式需要满足两点:</span></span><br><span class="line">        <span class="comment"># 1).pool.close()即进程池不再接受新的任务</span></span><br><span class="line">        <span class="comment"># 2).主进程不再等待进程池结束后再退出,需要进程池join()</span></span><br><span class="line">        <span class="comment">#     pool.join()</span></span><br><span class="line">        pool.apply_async(copy_work)</span><br><span class="line">    <span class="comment"># 1).pool.close()即进程池不再接受新的任务</span></span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment"># 2).主进程不再等待进程池结束后再退出,需要进程池join()</span></span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><h3 id="进程池中的Queue"><a href="#进程池中的Queue" class="headerlink" title="进程池中的Queue"></a>进程池中的Queue</h3><p>如果要使用Pool创建进程,就需要使用<code>multiprocessing.Manager()</code>中的<code>Queue()</code>，而不是<code>multiprocessing.Queue()</code></p><blockquote><p>用法:queue&#x3D;multiprocessing.Manager().Queue()</p></blockquote><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 思路:</span></span><br><span class="line"><span class="comment"># 1. 准备两个进程</span></span><br><span class="line"><span class="comment"># 2.准备队列,一个进程写入数据</span></span><br><span class="line"><span class="comment"># 3. 另一个进程读取数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.写入数据到队列的函数:</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_queue</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> queue.full():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;队列已满!!!&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        queue.put(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;写入数据:&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.读取数据到并显示的函数:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_queue</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> queue.empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;队列已空!!!&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        value = queue.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;读取到的数据:&#x27;</span>, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 创建进程池中的队列</span></span><br><span class="line">    queue = multiprocessing.Manager().Queue(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 使用进程池执行任务</span></span><br><span class="line">    <span class="comment"># 同步</span></span><br><span class="line">    <span class="comment"># pool.apply(write_queue, (queue,))</span></span><br><span class="line">    <span class="comment"># pool.apply(read_queue, (queue,))</span></span><br><span class="line">    <span class="comment"># 异步</span></span><br><span class="line">    <span class="comment"># wait()方法类似join()当前进程结束,才能执行下一个进程，如果没有wait方法读写的数据会有多种结果</span></span><br><span class="line">    result = pool.apply_async(write_queue, (queue,))</span><br><span class="line">    <span class="comment"># result.wait()</span></span><br><span class="line">    pool.apply_async(read_queue, (queue,))</span><br><span class="line">    <span class="comment"># close()表示不再接受新任务</span></span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment"># 主进程等待进程池结束</span></span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><h3 id="文件夹copy器-多进程"><a href="#文件夹copy器-多进程" class="headerlink" title="文件夹copy器-多进程"></a>文件夹copy器-多进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 从test-------&gt;dest</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">思路:</span><br><span class="line">1. 定义原路径和目标路径</span><br><span class="line">2. 在目标路径创建文件夹</span><br><span class="line">3. 获取源文件夹中所有的文件</span><br><span class="line">4. 遍历列表,获取文件名</span><br><span class="line">5. 定义函数拷贝文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拷贝函数:</span><br><span class="line">参数: 源文件夹 目标文件夹 文件名</span><br><span class="line">1. 拼接具体路径</span><br><span class="line">2. 打开源文件,创建目标文件</span><br><span class="line">3. 读物源文件内容,写入到目标文件</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import multiprocessing</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def copy_file(test_dir, dest_dir, file):</span><br><span class="line">    &quot;&quot;&quot;文件复制器,从源文件复制到目标文件</span><br><span class="line"></span><br><span class="line">    :param test_dir: 源文件夹</span><br><span class="line">    :param dest_dir: 目标文件夹</span><br><span class="line">    :param file: 文件名</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1. 拼接具体路径</span><br><span class="line">    test_file = os.path.join(test_dir, file)</span><br><span class="line">    dest_file = os.path.join(dest_dir, file)</span><br><span class="line">    # 2. 打开源文件,创建目标文件</span><br><span class="line">    with open(test_file, &#x27;rb&#x27;) as tf:</span><br><span class="line">        # 3. 读物源文件内容,写入到目标文件</span><br><span class="line">        with open(dest_file, &#x27;wb&#x27;) as df:</span><br><span class="line">            file_data = tf.read()</span><br><span class="line">            df.write(file_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 1. 定义原路径和目标路径</span><br><span class="line">    test_dir = &#x27;./test&#x27;</span><br><span class="line">    dest_dir = &#x27;./dest&#x27;</span><br><span class="line">    # 2. 在目标路径创建文件夹</span><br><span class="line">    try:</span><br><span class="line">        os.mkdir(dest_dir)</span><br><span class="line">    except FileExistsError:</span><br><span class="line">        print(&#x27;文件夹已存在&#x27;)</span><br><span class="line">    # 3. 获取源文件夹中所有的文件</span><br><span class="line">    file_list = os.listdir(test_dir)</span><br><span class="line">    # print(file_list)</span><br><span class="line">    # 创建进程池</span><br><span class="line">    pool = multiprocessing.Pool(5)</span><br><span class="line">    # 4. 遍历列表,获取文件名</span><br><span class="line">    for file in file_list:</span><br><span class="line">        # 5. 定义函数拷贝文件</span><br><span class="line">        # copy_file(test_dir, dest_dir, file)</span><br><span class="line">        # 多进程</span><br><span class="line">        pool.apply_async(copy_file, (test_dir, dest_dir, file))</span><br><span class="line">    # 进程池不再接受新的任务</span><br><span class="line">    pool.close()</span><br><span class="line">    # 主进程等待进程池结束</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程(Process)是资源分配的最小单位，也是线程的容器。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（二）-- 多线程</title>
    <link href="http://example.com/2022/09/28/Python%E8%BF%9B%E9%98%B6(%E4%BA%8C)%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2022/09/28/Python%E8%BF%9B%E9%98%B6(%E4%BA%8C)%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-09-28T13:23:31.000Z</published>
    <updated>2022-11-17T13:38:35.763Z</updated>
    
    <content type="html"><![CDATA[<p>Python多任务和线程</p><h1 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a><strong>多任务</strong></h1><ol><li><p>概念：同一时间，多个任务同时执行</p></li><li><p>优势：时间短，效率高</p></li><li><p>表现：在<code>Windows</code>系统中可以同时多个窗口运行多个任务。<code>Python</code>默认为单任务运行。</p></li></ol><span id="more"></span>  <h1 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a><strong>线程的基本使用</strong></h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>   可简单理解为是程序执行的一条分支，也是程序执行流程的最小单元。线程是被系统独立调用和分派的基本单位，线程自己并不拥有系统资源，只拥有一点在运行中必不可少的资源，但他可以同属一个进程的其他线程共享进程所拥有的全部资源。</p><ul><li><p>&#x3D;&#x3D;主线程&#x3D;&#x3D;：</p><blockquote><p>当一个程序启动时，就有一个进程被系统创建，与此同时一个线程也会被运行，该线程通常叫做程序<strong>主线程</strong>，也就是说，程序启动就会创建一个主线程。</p><p><strong>主线程</strong>的重要性有两方面：</p><ol><li><p>产生其他子线程的线程；</p></li><li><p>通常它必须最后完成执行。</p></li></ol></blockquote></li><li><p>&#x3D;&#x3D;子线程&#x3D;&#x3D;:</p><blockquote><p>可以看做是程序执行的一条分支，当子线程启动后会和主线程一起同时执行。</p></blockquote></li></ul><h3 id="使用threading模块子线程创建"><a href="#使用threading模块子线程创建" class="headerlink" title="使用threading模块子线程创建"></a><strong>使用threading模块子线程创建</strong></h3><ol><li><p>步骤：</p><ol><li><p>导入模块 <code>threading</code></p></li><li><p>使用<code>threading.Thread()</code>创建对象（子线程对象）</p></li><li><p>指定子线程执行的分支</p></li><li><p>启动子线程，<code>线程对象.start()</code></p></li></ol></li><li><p>案例：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#导入模块 `threading`</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单线程的使用：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nihao</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello,World&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 单线程调用</span></span><br><span class="line">    time1 = time.time()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        nihao()</span><br><span class="line">    time2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(time2 - time1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子线程调用：</span></span><br><span class="line">    time3 = time.time()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="comment">#    使用`threading.Thread()`创建对象（子线程对象）</span></span><br><span class="line">    <span class="comment"># 指定子线程执行的分支</span></span><br><span class="line">        thread_obj = threading.Thread(target=nihao)</span><br><span class="line">    <span class="comment">#   启动子线程，`线程对象.start()`</span></span><br><span class="line">        thread_obj.start()</span><br><span class="line">    time4 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(time4 - time3)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线程名称和数量"><a href="#线程名称和数量" class="headerlink" title="线程名称和数量"></a><strong>线程名称和数量</strong></h1><h3 id="查看线程数量"><a href="#查看线程数量" class="headerlink" title="查看线程数量"></a><strong>查看线程数量</strong></h3><ul><li><code>threading.enumerate()</code>：获取当前所有活跃的线程对象列表。使用<code>len()</code>对列表求长度可以看到当前活跃的线程的个数。</li></ul><h3 id="查看线程名称"><a href="#查看线程名称" class="headerlink" title="查看线程名称"></a><strong>查看线程名称</strong></h3><ul><li><code>threading.current_thread()</code>：获取当前线程对象，对象中含有名称。</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nihao</span>():</span><br><span class="line">    <span class="comment">#`threading.current_thread()`：获取当前线程对象，对象中含有名称</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello,World&#x27;</span>, threading.current_thread())</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_num = <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">    <span class="comment">#现在只有主线程</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;当前线程数量为：<span class="subst">&#123;thread_num&#125;</span>&#x27;</span>, threading.current_thread())</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        thread_obj = threading.Thread(target=nihao)</span><br><span class="line">        thread_obj.start()</span><br><span class="line">        <span class="comment">#`threading.enumerate()`：获取当前所有活跃的线程对象列表。</span></span><br><span class="line">        thread_num1 = <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;当前线程数量为：<span class="subst">&#123;thread_num1&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线程参数和顺序"><a href="#线程参数和顺序" class="headerlink" title="线程参数和顺序"></a>线程参数和顺序</h1><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h3><p>在线程中传递参数有三种方法：</p><ol><li>使用元组传递：<code>threading.Thread(target=函数名称,args=(参数1,参数2,...,参数n))</code></li><li>使用字典传递：<code>threading.Thread(target=函数名称,kwargs=&#123;参数名称:参数值,参数名称:参数值,参数名称:参数值,...&#125;)</code></li><li>混合使用元组和字典：<code>threading.Thread(target=函数名称,args=(参数1,参数2,...,参数n),kwargs=&#123;参数名称:参数值,参数名称:参数值,参数名称:参数值,...&#125;)</code></li></ol><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">name1, name2, words</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name1&#125;</span>对<span class="subst">&#123;name2&#125;</span>说<span class="subst">&#123;words&#125;</span>&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1.使用元组传递：`threading.Thread(target=函数名称,args=(参数1,参数2,...,参数n))`</span></span><br><span class="line">    thread_obj = threading.Thread(target=say, args=(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;你好啊！&#x27;</span>))</span><br><span class="line">    thread_obj.start()</span><br><span class="line">    <span class="comment"># 2.使用字典传递：`threading.Thread(target=函数名称,kwargs=&#123;参数名称:参数值,参数名称:参数值,参数名称:参数值,...&#125;)`</span></span><br><span class="line">    thread_obj = threading.Thread(target=say, kwargs=&#123;<span class="string">&#x27;name1&#x27;</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;name2&#x27;</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;words&#x27;</span>: <span class="string">&#x27;你好啊！&#x27;</span>&#125;)</span><br><span class="line">    thread_obj.start()</span><br><span class="line">    <span class="comment"># 3.混合使用元组和字典传递：`threading.Thread(target=函数名称,args=(参数1,参数2,...,参数n),kwargs=&#123;参数名称:参数值,参数名称:参数值,参数名称:参数值,...&#125;)`</span></span><br><span class="line">    thread_obj = threading.Thread(target=say, args=(<span class="string">&#x27;张三&#x27;</span>,), kwargs=&#123;<span class="string">&#x27;words&#x27;</span>: <span class="string">&#x27;吃了么！&#x27;</span>, <span class="string">&#x27;name2&#x27;</span>: <span class="string">&#x27;张三&#x27;</span>&#125;)</span><br><span class="line">    thread_obj.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a><strong>执行顺序</strong></h3><p>多线程程序的执行顺序是不确定的，当执行到<code>sleep</code>语句是线程将被阻塞，到<code>sleep</code>结束后，线程进入就绪状态，等待调度。而线程调度将自行选择一个线程执行。</p><p>注意：无法控制线程调度执行顺序，但可以通过别的方式来影响线程调度的方式。</p><h1 id="线程守护"><a href="#线程守护" class="headerlink" title="线程守护"></a>线程守护</h1><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>子线程和主线程的一种约定，当主线程结束时，子线程结束。Python默认不守护线程，即主线程结束，子线程在完成以后才结束，不会因为主线程停止而停止。</p><blockquote><p>原本利用<code>子线程.setDaemon(True)</code>来设置守护线程，但是该方法现在已经弃用，如今需要在创建线程是通过参数<code>daemon</code>来设置是否守护：True为守护线程，默认False不守护。</p></blockquote><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在工作中！！！&#x27;</span>, i + <span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 设置子线程为守护线程</span></span><br><span class="line">    thread_work = threading.Thread(target=work, daemon=<span class="literal">True</span>)</span><br><span class="line">    thread_work.start()</span><br><span class="line">    <span class="comment"># 让主线程在4秒后完成工作，下班</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;工作完成，下班！！！&#x27;</span>)</span><br><span class="line">    exit()</span><br></pre></td></tr></table></figure><h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><ul><li>&#x3D;&#x3D;并发&#x3D;&#x3D;：指的是&#x3D;&#x3D;任务数多余CPU核数&#x3D;&#x3D;，通过操作系统的任务调度算法，实现多个任务‘一起’执行。（实际总有任务没有执行，只不过切换任务速度非常快，看上去一起执行而已）</li><li>&#x3D;&#x3D;并行&#x3D;&#x3D;：指的是&#x3D;&#x3D;任务数小于等于CPU核数&#x3D;&#x3D;，让任务真的一起执行</li><li>真正的并行执行多任务只能在多核CPU上实现，但是由于任务数量远远多余CPU的核心数量，所以操作系统也会把很多任务轮流调度到每个核心上执行。</li></ul><h1 id="自定义线程类"><a href="#自定义线程类" class="headerlink" title="自定义线程类"></a>自定义线程类</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>导入threading模块</p></li><li><p>创建类并且继承threading.Thread</p></li><li><p>重写父类run方法</p></li><li><p>创建线程并且用start()调用</p><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 导入threading模块</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建类并且继承threading.Thread</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="comment"># 先调用父类的初始化方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 重写父类run方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;正在进行自定义线程！！！线程名称： <span class="subst">&#123;self.name&#125;</span>&#x27;</span>, self.num)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 4. 创建线程并且用start()调用</span></span><br><span class="line">    mythread = MyThread(<span class="number">10</span>)</span><br><span class="line">    mythread.start()</span><br></pre></td></tr></table></figure></li></ol><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>Thread类</p><ul><li>run方法</li><li>start()</li><li>start()中调用了run方法</li></ul><h3 id="自定义线程类的init方法问题"><a href="#自定义线程类的init方法问题" class="headerlink" title="自定义线程类的init方法问题"></a>自定义线程类的init方法问题</h3><blockquote><p>子类先通过super调用父类的初始化方法，子类再初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">    <span class="comment"># 先调用父类的初始化方法</span></span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.num = <span class="number">10</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="多线程共享全局变量"><a href="#多线程共享全局变量" class="headerlink" title="多线程共享全局变量"></a>多线程共享全局变量</h1><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>多线程之间可以共享全局变量。</p><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="comment"># 定义全局变量</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在唱第<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>首歌&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;在唱第<span class="subst">&#123;num&#125;</span>首歌时,张三唱起了歌!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_sing = threading.Thread(target=sing)</span><br><span class="line">    thread_dance = threading.Thread(target=dance)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    thread_sing.start()</span><br><span class="line">    thread_dance.start()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><blockquote><p>多个线程同同时访问同一个资源，会出现资源竞争的问题</p></blockquote><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="comment"># 定义全局变量</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;张三唱了<span class="subst">&#123;num&#125;</span>首歌&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing2</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;张三和李四唱了<span class="subst">&#123;num&#125;</span>首歌&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_sing = threading.Thread(target=sing)</span><br><span class="line">    thread_sing2 = threading.Thread(target=sing2)</span><br><span class="line">    thread_sing.start()</span><br><span class="line">    thread_sing2.start()</span><br><span class="line">    <span class="comment"># 让主线程等待子线程结束</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><blockquote><p>在该案例中会出现资源竞争问题,导致num与预想结果不同</p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>优先让某个线程先执行。但是会把多线程变为单线程，影响整体性能。</p><blockquote><p>线程对象.join()</p></blockquote><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="comment"># 定义全局变量</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;张三唱了<span class="subst">&#123;num&#125;</span>首歌&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing2</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;张三和李四唱了<span class="subst">&#123;num&#125;</span>首歌&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_sing = threading.Thread(target=sing)</span><br><span class="line">    thread_sing2 = threading.Thread(target=sing2)</span><br><span class="line">    thread_sing.start()</span><br><span class="line">    <span class="comment"># 让子线程thread_sing优先执行</span></span><br><span class="line">    thread_sing.join()</span><br><span class="line">    thread_sing2.start()</span><br><span class="line">    <span class="comment"># 让主线程等待子线程结束</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li><p>&#x3D;&#x3D;同步&#x3D;&#x3D;：多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行，&#x3D;&#x3D;只有一个主线&#x3D;&#x3D;。</p></li><li><p>&#x3D;&#x3D;异步&#x3D;&#x3D;：指的是多个任务之间执行没有先后顺序，可以同时运行，执行先后顺序不会有什么影响，&#x3D;&#x3D;存在多条运行主线&#x3D;&#x3D;。</p></li></ul><h3 id="线程的锁机制"><a href="#线程的锁机制" class="headerlink" title="线程的锁机制"></a>线程的锁机制</h3><p>当线程获取资源后，立即进行锁定，资源使用完毕后再解锁，有效的保证同一时间只有线程在使用资源。</p><ul><li><p>解决线程同时修改全局变量的方式：</p><p>对于上一部分提出对num计算出错的问题，可以通过&#x3D;&#x3D;线程同步&#x3D;&#x3D;来解决：</p><ol><li>系统调用sing，获取num的值为0，此时上一把锁，不允许其他线程操作num；</li><li>sing对num进行计算；</li><li>sing解锁，此时num的值为sing计算后的值，其他线程就可以使用计算后的num了；</li><li>同理其他线程在对num进行修改时，都要先上锁，处理后再解锁，再上锁过程中不允许其他线程访问，就保证了数据的准确性</li></ol></li></ul><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>&#x3D;&#x3D;当多个线程几乎同时修改某一个共享数据的时候，需要同步控制。&#x3D;&#x3D;线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制就是引入&#x3D;&#x3D;互斥锁&#x3D;&#x3D;。</p><p>互斥锁为资源引入一个状态：&#x3D;&#x3D;锁定&#x2F;非锁定&#x3D;&#x3D;</p><p>某个线程要更改共享数据时，先将其锁定，此时资源状态为&#x3D;&#x3D;锁定&#x3D;&#x3D;，其他线程不可更改；直到该线程释放资源，将资源状态变成&#x3D;&#x3D;非锁定&#x3D;&#x3D;，其他线程才能再次锁定该资源。&#x3D;&#x3D;互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。&#x3D;&#x3D;</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>threading模块中定义了Lock类，用来处理锁定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建锁</span></span><br><span class="line">    lock = threading.Lock()    <span class="comment"># #2.上锁</span></span><br><span class="line">    lock.acquire()</span><br><span class="line"><span class="comment"># 3. 释放锁</span></span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><p>使用原则：尽可能少的去锁定竞争资源。</p><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="comment"># 定义全局变量</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="comment"># 2.上锁</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 3. 释放锁</span></span><br><span class="line">    lock.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;张三唱了<span class="subst">&#123;num&#125;</span>首歌&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing2</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="comment"># 2.上锁</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 3. 释放锁</span></span><br><span class="line">    lock.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;张三和李四唱了<span class="subst">&#123;num&#125;</span>首歌&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1.创建锁</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="comment"># 创建子线程</span></span><br><span class="line">    thread_sing = threading.Thread(target=sing)</span><br><span class="line">    thread_sing2 = threading.Thread(target=sing2)</span><br><span class="line">    thread_sing.start()</span><br><span class="line">    thread_sing2.start()</span><br><span class="line">    <span class="comment"># 让主线程等待子线程结束</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在线程之间共享多个资源的时候，如果两个线程分别占有有一部分资源并且同时等待对方的资源，就会造成&#x3D;&#x3D;死锁&#x3D;&#x3D;。</p><p>尽管死锁很少发生，但是一旦发生就会造成应用的停止响应。</p><p>死锁案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">index</span>):</span><br><span class="line">    lst = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上锁</span></span><br><span class="line">    lock.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(lst):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;下标越界:<span class="subst">&#123;index&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(lst[index])</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># 解锁</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">        thread = threading.Thread(target=get_value, kwargs=&#123;<span class="string">&#x27;index&#x27;</span>: i&#125;)</span><br><span class="line">        thread.start()</span><br></pre></td></tr></table></figure><p>在上面案例中，因为索引大于列表长度，从而直接返回并没有对资源进行解锁，所以造成死锁。</p><p>解决方法：在适当位置对资源进行释放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(lst):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;下标越界:<span class="subst">&#123;index&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment">#解锁</span></span><br><span class="line">    lock.release()</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h1 id="TCP服务器框架"><a href="#TCP服务器框架" class="headerlink" title="TCP服务器框架"></a>TCP服务器框架</h1><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>导入模块</p></li><li><p>创建套接字</p></li><li><p>设置地址可以重用</p></li><li><p>绑定端口</p></li><li><p>设置监听，套接字由主动变为被动</p></li><li><p>接受客户端连接</p></li><li><p>接受客户端发送的信息</p></li><li><p>解码数据并进行输出</p></li><li><p>关闭和当前客户端连接</p><p>单线程服务器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 导入模块</span></span><br><span class="line"><span class="comment"># 2. 创建套接字</span></span><br><span class="line">tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 3. 设置地址可以重用</span></span><br><span class="line">tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 4. 绑定端口</span></span><br><span class="line">tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 5. 设置监听，套接字由主动变为被动</span></span><br><span class="line">tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"><span class="comment"># 6. 接受客户端连接</span></span><br><span class="line">new_client_socket, ip_port = tcp_server_socket.accept()</span><br><span class="line"><span class="comment"># 7. 接受客户端发送的信息</span></span><br><span class="line">recv_data = new_client_socket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 8. 解码数据并进行输出</span></span><br><span class="line">recv_text = recv_data.decode(<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;收到来自<span class="subst">&#123;<span class="built_in">str</span>(ip_port)&#125;</span>的信息:<span class="subst">&#123;recv_text&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 9. 关闭和当前客户端连接</span></span><br><span class="line">new_client_socket.close()</span><br><span class="line">tcp_server_socket.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多线程服务器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 导入模块</span></span><br><span class="line"><span class="comment"># 2. 创建套接字</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 3. 设置地址可以重用</span></span><br><span class="line">tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 4. 绑定端口</span></span><br><span class="line">tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 5. 设置监听，套接字由主动变为被动</span></span><br><span class="line">tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_msg</span>(<span class="params">new_client_socket, ip_port</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 7. 接受客户端发送的信息</span></span><br><span class="line">        recv_data = new_client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> recv_data:</span><br><span class="line">            <span class="comment"># 8. 解码数据并进行输出</span></span><br><span class="line">            recv_text = recv_data.decode(<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;收到来自<span class="subst">&#123;<span class="built_in">str</span>(ip_port)&#125;</span>的信息:<span class="subst">&#123;recv_text&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 9. 关闭和当前客户端连接</span></span><br><span class="line">    new_client_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 6. 接受客户端连接</span></span><br><span class="line">    new_client_socket, ip_port = tcp_server_socket.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;新用户上线:&#x27;</span>, ip_port)</span><br><span class="line">    <span class="comment"># recv_msg(new_client_socket, ip_port)</span></span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    <span class="comment"># 创建守护线程</span></span><br><span class="line">    thread = threading.Thread(target=recv_msg, args=(new_client_socket, ip_port), daemon=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    thread.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python多任务和线程&lt;/p&gt;
&lt;h1 id=&quot;多任务&quot;&gt;&lt;a href=&quot;#多任务&quot; class=&quot;headerlink&quot; title=&quot;多任务&quot;&gt;&lt;/a&gt;&lt;strong&gt;多任务&lt;/strong&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;概念：同一时间，多个任务同时执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优势：时间短，效率高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;表现：在&lt;code&gt;Windows&lt;/code&gt;系统中可以同时多个窗口运行多个任务。&lt;code&gt;Python&lt;/code&gt;默认为单任务运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶（一）-- 面向对象编程</title>
    <link href="http://example.com/2022/09/21/Python%E8%BF%9B%E9%98%B6(%E4%B8%80)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/09/21/Python%E8%BF%9B%E9%98%B6(%E4%B8%80)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2022-09-21T13:23:31.000Z</published>
    <updated>2022-11-17T13:35:50.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的定义和使用"><a href="#类的定义和使用" class="headerlink" title="类的定义和使用"></a>类的定义和使用</h1><p>类是对某一类事物的抽象描述,如动物类、玩具类等。它是一个抽象的概念。类用于描述多个对象的共同特征，它是对象的模板。对象用于描述现实的个体，他是类的实例。所以对象时根据类创建的，并且一个类可以用于多个对象。</p><span id="more"></span><p>类是由类名、属性和方法三部分组成：</p><ol><li>类名：类的名称，习惯上，他的首写字母是大写，不能用阿拉伯数字开头</li><li>属性：用于描述事务的特征</li><li>方法：用于描述事物的行为</li></ol><p>在Python中，可以使用class关键字声明一个类，其基本语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    类的属性</span><br><span class="line">    类的方法</span><br></pre></td></tr></table></figure><p>程序要想完成具体的功能,仅有类是不够的,还需要根据类创建实例对象.将类实例化为一个对象语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名 = 类名([相关参数])</span><br></pre></td></tr></table></figure><p>给对象添加属性格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.新的属性名 = 值</span><br></pre></td></tr></table></figure><h1 id="数据成员与成员方法"><a href="#数据成员与成员方法" class="headerlink" title="数据成员与成员方法"></a>数据成员与成员方法</h1><h2 id="私有成员与共有成员"><a href="#私有成员与共有成员" class="headerlink" title="私有成员与共有成员"></a>私有成员与共有成员</h2><p>从形式上看,在定义类的成员时,如果成员名以两个下划线(__开头)则表示是私有成员,但是Python并没有对私有成员提供严格的访问保护机制.私有成员在类的外部不能直接访问.Python提供了一种特殊方式‘对象名.<code>_类名__xxx</code>’可以访问私有成员,但这会破坏类的封装,不推荐使用.</p><p>在Python中,以下划线开头和结束的成员名含有特殊含义,类定义中用下划线作为变量名和方法名前缀和后缀来表示类的特殊成员.</p><ul><li>_xxx:保护成员,不能用‘from moudel import *’,自由类对象和子类对象可以访问这些成员。</li><li><code>__xxx__</code>: 系统定义的特殊成员</li><li><code>__xxx</code>:类中的私有成员,一般只有类对象自己能访问,子类对象也不能访问到这个成员,但是在对象外部可以通过‘<code>对象名._类名__xxx</code>’这样的特殊方式访问</li><li>python不存在严格意义上的私有成员</li></ul><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><p>数据成员用来说明对象特有的一些属性,数据成员大体分为两类:&#x3D;&#x3D;属于对象的数据成员&#x3D;&#x3D;和&#x3D;&#x3D;属于类的数据成员&#x3D;&#x3D;.属于对象的数据成员主要指在构造函数<code>__init__()</code>中定义的,定义和使用必须以self为前缀,同一个类的不同对象之间的数据成员互不影响;属于类的数据成员时该类所有对象共享的,不属于任何一个对象,在定义类时这类数据成员不在任何一个成员方法的定义中</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="公有方法和私有方法"><a href="#公有方法和私有方法" class="headerlink" title="公有方法和私有方法"></a>公有方法和私有方法</h3><p>在类中定义的方法可以分为四类:公有方法、私有方法、静态方法和类方法</p><p>公有方法和私有方法一般是指属于对象的实例方法，其中私有方法的名称以两个下划线（__)开始,每个对象都有自己的私有方法和公有方法,这两类方法都可以访问属于类和对象的成员;公有方法通过对象名直接调用,私有方法不能通过对象名字直接调用,只能在实例方法中通过self调用或者在外部通过Python支持的特殊方式调用.</p><p>类的所有实例方法都至少有一个名为self的参数,并且是方法的第一形参,self代表对象自身.</p><p>静态方法和类方法都可以通过类名和对象名调用,但不能直接访问属于对象的成员,智能访问属于类的成员。一般将cls作为类方法的第一个参数，表示该类自身，在调用类方法时不需要为该参数传递值</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Python中允许声明与类的对象实例无关的方法，称为静态方法。静态方法不对特定实例进行操作，在静态方法中访问对象实例会导致错误。静态方法中访问对象会导致错误。静态方法通过装饰器<code>@staticmethod</code>进行定义,其格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">静态方法</span>(<span class="params">[形参列表]</span>):</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><p>静态方法一般通过类名进行访问,也可以通过对象实例进行调用.其格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.静态方法名([实参列表])</span><br></pre></td></tr></table></figure><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>Python中允许声明属于类本身的方法,即类方法.类方法不对特定实例进行操作,在类方法中访问对象实例属性会导致错误.类方法通过<code>@classmethod</code>进行定义,第一个形式参数必须为类对象本身,通常是cls.类方法的生命格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">类方法名</span>(<span class="params">cls,[形参列表]</span>):</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><p>类方法一般通过类名进行访问,也可以通过对象实例进行调用,格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.类方法([实参列表])</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>类的数据成员是在类中定义的成员变量(域),用来存储描述类的特征的值,称为&#x3D;&#x3D;属性&#x3D;&#x3D;,属性可以被类中的方法访问,也可以通过类对象或者实例对象进行访问.而在函数体或代码块中定义的局部变量,则只能在其定义的范围内进行访问.</p><p>属性实际上是类中的变量.python中定义变量不需要声明,可以直接使用.建议在类定义的开始位置初始化类属性,或者在构造函数(<code>__init__</code>)中初始化实例属性</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p>通过<code>self.变量名</code>定义的属性称为实例属性,又称为实例变量。类的每个实例都包含该类的实例变量的一个单独副本，实例变量属于特定的实例。实例变量在类的内部通过self访问，在外部通过对象实例访问。</p><p>实例属性一般在<code>__init__()</code>方法中通过如下形式初始化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.实例变量名 = 初始值</span><br></pre></td></tr></table></figure><p>然后在其他实例函数中,通过self访问:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.实例变量名 = 值  <span class="comment">#写入</span></span><br><span class="line">self.实例变量名       <span class="comment">#读取</span></span><br></pre></td></tr></table></figure><p>创建对象实例后,通过对象实例访问:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = 类名()     <span class="comment">#创建对象实例</span></span><br><span class="line">obj1.实例变量名 = 值 <span class="comment">#写入</span></span><br><span class="line">obj1.实例变量名   <span class="comment">#读取</span></span><br></pre></td></tr></table></figure><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>Python允许声明类对象本身的变量,即类属性,又称为类变量、静态变量。类属性属于整个类，不是特定实例的一部分，而是所有实例之间共享一个副本。</p><p>类属性一般在类体中通过如下形式初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类变量名 = 初始值</span><br></pre></td></tr></table></figure><p>然后在其类定义的方法中或外部代码中,通过类名访问:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.类变量名 = 值         <span class="comment">#写入</span></span><br><span class="line">类名.类变量名              <span class="comment">#读取</span></span><br></pre></td></tr></table></figure><p>注意:类属性如果通过<code>obj.属性名</code>进行访问,则属于该实例的实例属性.虽然类属性可以使用对象实例来访问,但这样容易造成困惑,应该使用标准的访问方式: <code>类名.类变量名</code></p><h3 id="私有属性和共有属性"><a href="#私有属性和共有属性" class="headerlink" title="私有属性和共有属性"></a>私有属性和共有属性</h3><p>Python类的成员没有访问控制限制,这与其他面相对象的语言不同。</p><p>通常约定两个下划线开头，但是不以两个下划线结束的属性还私有的，其他为公共的，不能直接访问私有属性，但是可以在方法中访问。</p><h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>面向对象编程的封装性性原则要求不直接访问类中的数据成员。Python中可以定义私有属性，然后定义相应的访问该私有属性属性的函数，并且使用@property装饰器装饰这些函数。程序可以把函数‘当作’属性访问，从而提供更加友好的访问方式</p><p>@property装饰器默认提供一个只读属性，如果需要，可以使用对应的getter、setter和deleter装饰器实现其他访问器函数。</p><h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><p>python对象中包含许多以双下划线开始和结束的方法，称为特殊属性，常用特殊属性如下：</p><table><thead><tr><th>特殊方法</th><th>含义</th></tr></thead><tbody><tr><td><code>object.__dict__</code></td><td>对象的属性字典</td></tr><tr><td><code>instance.__class__</code></td><td>对象所属的类</td></tr><tr><td><code>class.__对象所属的类__</code></td><td>对象所属的类</td></tr><tr><td><code>class.__bases__</code></td><td>类的基本元组</td></tr><tr><td><code>class.__base__</code></td><td>类的基类</td></tr><tr><td><code>class.__name__</code></td><td>类的名称</td></tr><tr><td><code>class.__mro__</code></td><td>方法查找顺序,基类元组</td></tr><tr><td><code>class.mro()</code></td><td>同上,可被子类重写</td></tr><tr><td><code>class.__subclasses__()</code></td><td>子类列表</td></tr></tbody></table><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>Python中,可以赋予一个对象自定义的属性,即类定义中不存在的属性.对象通过特殊属性<code>__dict__</code>存储自定义属性。</p><p>通过重载<code>__getattr__</code>和<code>__setattr__</code>,可以拦截对成员的访问,从而自定义属性的行为。<code>__getattr__</code>只有在访问不存在的成员时才被调用,<code>__getattribute__</code>拦截所有获取操作.在<code>__getattribute__</code>中不要使用<code>return self.__dict__[name]</code>返回结果,因为在访问<code>self.__dict__</code>时同样会被<code>__getattribute__</code>拦截,从而造成无限递归想成列循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__getattr__(self,name)      <span class="comment"># 获取属性,比__getattribute__优先调用</span></span><br><span class="line">__getattribute__(self,name)   <span class="comment"># 获取属性</span></span><br><span class="line">__setatt__(self,name,value)    <span class="comment"># 设置属性</span></span><br><span class="line">__delattr__(self,name)       <span class="comment">#删除属性</span></span><br></pre></td></tr></table></figure><h1 id="继承多态封装"><a href="#继承多态封装" class="headerlink" title="继承多态封装"></a>继承多态封装</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>在Python中,所谓‘继承’就是在一个已存在的类的基础上建立一个新类,已存在的类称为‘基类’或‘父类’,新建立的类称为‘派生类’或者‘子类’。</p><p>继承语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">子类名</span>(<span class="title class_ inherited__">父类名</span>):</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>假设一个类名为A,B类是A类的子类,例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br></pre></td></tr></table></figure><p>如果在定义类的时候没有标注出父类,那么这个类默认是继承自object的.</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>现实中一个子类往往会有多个父类.多继承可以看做对单继承的扩展,通过在子类名称的括号中标注出要继承的多个父类,并且多个父类间使用逗号分割,多继承的格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">子类</span>(父类<span class="number">1</span>,父类<span class="number">2</span>,...,父类n)</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在强类型语言（Java或者C#）中，多态是指允许使用一个父类类型的变量或常量来引用一个子类类型对象，根据被引用子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果及时用父类类型来调用子类的方法。</p><p>在python中,多态指在不考虑对象类型下使用对象,相比于强类型，Python更推崇‘鸭子类型’，即它不关注对象的类型，而是关注对象具有的行为。</p><h1 id="特殊方法与运算符重载"><a href="#特殊方法与运算符重载" class="headerlink" title="特殊方法与运算符重载"></a>特殊方法与运算符重载</h1><h2 id="对象的特殊方法概述"><a href="#对象的特殊方法概述" class="headerlink" title="对象的特殊方法概述"></a>对象的特殊方法概述</h2><p>Python对象中包含了许多以双下划线开始和结束的方法，称为特殊方法。特殊方法通常在针对对象的某种操作时自动调用。</p><table><thead><tr><th>特殊方法</th><th>含义</th></tr></thead><tbody><tr><td><code>__It__</code>、<code>__add__</code>等</td><td>对应运算符&lt;、+等</td></tr><tr><td><code>__init__</code>、<code>__del__</code></td><td>创建或销毁对象时调用</td></tr><tr><td><code>__len__</code></td><td>对应于内置函数len()</td></tr><tr><td><code>__setitem__</code>、<code>__getitem__</code></td><td>按索引赋值取值</td></tr><tr><td><code>__repr__(self)</code></td><td>对应于内置函数repr()</td></tr><tr><td><code>__str__(self)</code></td><td>对应于内置函数str()</td></tr><tr><td><code>__bytes__(self)</code></td><td>对应于内置函数bytes()</td></tr><tr><td><code>__format__(self,format_spec)</code></td><td>对应于内置函数format()</td></tr><tr><td><code>__bool__(self)</code></td><td>对应内置函数bool()</td></tr><tr><td><code>__hash__(self)</code></td><td>对应于内置函数hash()</td></tr><tr><td><code>__dir__(self)</code></td><td>对应于内置函数dir()</td></tr></tbody></table><h2 id="运算符重载与对象的特殊方法"><a href="#运算符重载与对象的特殊方法" class="headerlink" title="运算符重载与对象的特殊方法"></a>运算符重载与对象的特殊方法</h2><p>Python的运算符实际上是通过调用对象的特殊方法实现的.</p><table><thead><tr><th>运算符</th><th>特殊方法</th><th>含义</th></tr></thead><tbody><tr><td>&gt;、&gt;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;</td><td><code>__ge__</code> <code>__gt__</code> <code>__ne__</code> <code>__It__</code> <code>__le__</code> <code>__eq__</code></td><td>比较运算符</td></tr><tr><td>|、^、&amp;</td><td><code>__or__</code> <code>__ror__</code> <code>__xor__</code> <code>__rxor__</code>  <code>__and__</code>  <code>__rand__</code></td><td>按位与、异或、与</td></tr><tr><td>|&#x3D;、^&#x3D;、&amp;&#x3D;</td><td><code>__ior__</code> <code>__ixor__</code> <code>__iand__</code></td><td>按位复合赋值运算</td></tr><tr><td>&lt;&lt;、&gt;&gt;</td><td><code>__lshift__</code> <code>__rlshift__</code> <code>__rshift__</code> <code>__rrshift__</code></td><td>移位运算</td></tr><tr><td>&lt;&lt;&#x3D;、&gt;&gt;&#x3D;</td><td><code>__ilshift__</code> <code>__irlshift__</code> <code>__irshift__</code> <code>__irrshift__</code></td><td>移位复合赋值运算</td></tr><tr><td>+、-</td><td><code>__add__</code> <code>__radd__</code> <code>__sub__</code> <code>__rsub__</code></td><td>加法与减法</td></tr><tr><td>+&#x3D;、-&#x3D;</td><td><code>__iaddr__</code> <code>__isub__</code></td><td>加减符合赋值运算</td></tr><tr><td>*、&#x2F;、%、&#x2F;&#x2F;</td><td><code>__mul__</code> <code>__rmul__</code> <code>__truediv__</code> <code>__rturediv__</code> <code>__mod__</code> <code>__rmod__</code> <code>__rfloordiv__</code> <code>__floordiv__</code></td><td>乘法、除法、取余、整数除法</td></tr><tr><td>*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&#x2F;&#x2F;&#x3D;</td><td><code>__imul__</code> <code>__idiv__</code> <code>__itruediv__</code> <code>__imod__</code> <code>__ifloordiv__</code></td><td>乘除复合赋值运算</td></tr><tr><td>+x、-x</td><td><code>__pos__</code> <code>__neg__</code></td><td>正负号</td></tr><tr><td>~X</td><td><code>__invert__</code></td><td>按位翻转</td></tr><tr><td><code>**</code>、<code>**</code>&#x3D;</td><td><code>__pow__</code> <code>__rpow__</code> <code>__ipow__</code></td><td>指数运算</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;类的定义和使用&quot;&gt;&lt;a href=&quot;#类的定义和使用&quot; class=&quot;headerlink&quot; title=&quot;类的定义和使用&quot;&gt;&lt;/a&gt;类的定义和使用&lt;/h1&gt;&lt;p&gt;类是对某一类事物的抽象描述,如动物类、玩具类等。它是一个抽象的概念。类用于描述多个对象的共同特征，它是对象的模板。对象用于描述现实的个体，他是类的实例。所以对象时根据类创建的，并且一个类可以用于多个对象。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="进阶" scheme="http://example.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="面向对象" scheme="http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python基础(六)--函数的定义与调用</title>
    <link href="http://example.com/2022/09/20/Python%E5%9F%BA%E7%A1%80(%E5%85%AD)%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2022/09/20/Python%E5%9F%BA%E7%A1%80(%E5%85%AD)%E5%87%BD%E6%95%B0/</id>
    <published>2022-09-20T13:23:31.000Z</published>
    <updated>2022-09-20T13:45:47.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数的定义与调用"><a href="#函数的定义与调用" class="headerlink" title="函数的定义与调用"></a>函数的定义与调用</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数是模块化程序设计的基本构成单位,在Python中函数也是对象,使用def语句创建<span id="more"></span> ,格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">[形参列表]</span>):</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><ul><li>函数名为有效的标识符,形参列表为函数的参数.函数定义的第一行称为函数签名,函数签名指定函数名称以及函数的每个形式参数变量名称。</li><li>声明函数时，可以声明函数的参数，即形式参数；调用函数时，需要提供函数所需参数的值，即实际参数，简称实参。</li><li>def是复核语句，故函数体需要采用书写缩进</li><li>函数可以用return返回值</li><li>def是执行语句，Python解释执行def语句时，会创建一个函数对象并绑定到函数名对象</li></ul><p>案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求正方形面积？</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">S</span>(<span class="params">d</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(d) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(S(<span class="number">5</span>))   ——————&gt;结果为<span class="number">25</span></span><br></pre></td></tr></table></figure><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>函数调用时,根据需要,可以传入指定实际传入的参数值。函数调用语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名([实参列表])</span><br></pre></td></tr></table></figure><ul><li>函数名是当前作用域中可用的函数对象.函数定义位置必须在调用该函数的全局代码之前,典型的Python程序结构为: 1 import语句,2 函数定义,3全局代码</li><li>实参列表必须与函数定义的形参列表一一对应。</li><li>函数调用的是表达式.</li></ul><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>return语句和函数返回值:</p><p>在函数中使用return语句可以实现从函数中返回一个值并且跳出函数的功能</p><p>多条return语句:</p><p>return语句可以放置在函数的任意位置,当执行第一个return语句时,程序返回到调用程序</p><p>返回多个值:</p><p>在函数体中使用return语句可实现返回一个值并且跳出函数,也可以返回多个值,则返回一个元组.</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数也就是没有名称的函数,也就是不需要def定义定义的函数。如果要声明匿名函数，需要使用lambda关键字格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1[,arg2,...argn]]:expression</span><br></pre></td></tr></table></figure><p><code>[arg1[,arg2,...argn]]</code>表示函数的参数,<code>expression</code>为函数的表达式,其结果为函数的返回值</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add=<span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">5</span>,<span class="number">7</span>))   ----&gt;<span class="number">12</span></span><br></pre></td></tr></table></figure><h1 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h1><h2 id="默认值参数"><a href="#默认值参数" class="headerlink" title="默认值参数"></a>默认值参数</h2><p>​就是在定义函数时为形参设置默认值,调用函数时,可以不用为设置了默认值的形参传递值,此时函数将会使用默认值。格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">...,形参名=默认值</span>):</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>默认值参数必须出现在函数参数列表的最右侧,即任何默认参数右不能再出现非默认参数.</li><li>如果函数的默认参数不是调用时传递的,而是通过其他方式赋值,那默认参数的值可能会在函数定义时确定,而不是调用时.</li></ul><h2 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h2><p>​关键参数主要指调用函数时的参数传递方式,与函数定义无关.通过关键参数可以按照参数名称传递值,实参顺序可以与形参顺序不一致,但是不影响参数值的传递。</p><h2 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h2><p>可变长度参数在定义函数时主要有两种方法<code>*agrs</code>和<code>**kwargs</code>,前者用来接收任意多个参数并将其放在一个元组中,后者接收类似于关键参数,显示赋值形式的多个实参,并将其放入字典.</p><h2 id="参数传递时的序列解包"><a href="#参数传递时的序列解包" class="headerlink" title="参数传递时的序列解包"></a>参数传递时的序列解包</h2><p>调用含有多个参数的函数时,可以使用python序列作为实参,并且在实参前加一个*号,python解释器会自动进行解包,然后传递给多个变量形参.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a+b+c)</span><br><span class="line">tup=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">demo(*tup)   ----&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>字典对象作为实参时,默认使用字典的‘键’,如果使用键值对则需要使用items()方法,如果用值作为参数则调用values()方法</li><li>实参中元素个数与形参个数必须相等</li><li>解包后的实参会被当做普通位置参数对待,并且会在关键参数和使用两个星号进行序列解包的参数之前进行处理</li></ul><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>变量声明位置不同,其可以被访问的范围也不同。变量的可访问位置称为变量作用域。变量按作用域可以分为：全局变量、局部变量。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在函数和类定义之外声明的变量称为全局变量。全局变量的作用域为为其定义的模块，从定义的位置起直到文件结束。</p><p>通过<code>import</code>导入模块，也可以通过全局限定名称‘模块名.变量名’访问。或则通过<code>from ...import </code>语句导入模块的变量访问。</p><p>不同模块都可以访问全局变量，这也导致了全局变量的不稳定性，全局变量降低了函数和模块之间的通用性，也降低了代码的可读性。一般情况下，应该尽量避免使用全局变量，全局变量一般作为常量使用。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在函数中声明的变量称为局部变量，其作用域为函数体。</p><p>全局代码不能引用函数中的局部变量或则像是参数变量，一个函数也不能引用另一个函数中的局部变量或则像是参数变量。</p><p>如果在局部变量和全局变量重名，则局部变量优先。</p><h2 id="全局语句global"><a href="#全局语句global" class="headerlink" title="全局语句global"></a>全局语句<code>global</code></h2><p>在函数体中可以引用全局变量，但如果函数内部的变量名是第一次出现且在赋值语句之前，则解释为定义局部变量。</p><p>如果要为定义在函数体外的全局变量赋值，可以使用<code>global</code>语句，表明变量实在外面定义的全局变量。global语句可以指定多个全局变量。一般要避免使用全局变量，全局变量会使程序的可读性变差。</p><h2 id="非局部变量nonlocal"><a href="#非局部变量nonlocal" class="headerlink" title="非局部变量nonlocal"></a>非局部变量<code>nonlocal</code></h2><p>在函数体内，可以定义嵌套函数，在嵌套函数中，如果要为定义在上级函数体的局部变量，可以使用nonlocal语句，表明变量不是所在块的局部变量，而是在上级函数体中的局部变量。nonlocal语句可以指定多个非局部变量。</p><h2 id="输出局部变量和全局变量"><a href="#输出局部变量和全局变量" class="headerlink" title="输出局部变量和全局变量"></a>输出局部变量和全局变量</h2><p>在程序中会生成各种局部变量和全局变量。使用内置函数<code>globals()</code>和<code>locals()</code>,可以查看并输出局部变量和全局变量列表。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>如果在一个内部函数中对外部函数作用域的变量进行引用，那么内部函数就会称为闭包，闭包需要满足三个条件：</p><ul><li>存在于嵌套关系的函数中</li><li>嵌套的内部函数引用了外部函数的变量</li><li>嵌套的外部函数会将内部函数名作为返回值返回</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">s=<span class="number">0</span></span>):</span><br><span class="line">    a = [s]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deem</span>():</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">6</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deem()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = (demo(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(a)    <span class="comment">#-----&gt;12</span></span><br></pre></td></tr></table></figure><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归函数即自调用函数，在函数内部直接或间接地自己调用自己，即函数的嵌套调用函数本身。递归函数常常用来实现数值计算。</p><p>递归函数原理：</p><p>每个函数必须包括终止条件和递归步骤两个主要部分</p><ul><li>终止条件：表示递归的结束条件，用于返回函数值不在递归调用</li><li>递归步骤：递归步骤把第n步的参数值与第n-1步的参数值的函数关联</li></ul><p>递归需要注意问题：</p><ol><li>必须设置终止条件，如果没有终止条件将会导致无限递归</li><li>必须保证收敛，递归调用解决的子问题的规模必须小于原始问题的规模</li><li>必须保证内存和运算消耗控制在一定范围。</li></ol><p>递归函数应用：</p><p>计算最大公约数，如果p和q两个数p&gt;q,则p和q的最大公约数等于q和p%q的最大公约数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">p, q</span>):</span><br><span class="line">    <span class="keyword">if</span> q == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">return</span> h(q, p % q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = <span class="number">12</span></span><br><span class="line">q = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(h(p, q))   <span class="comment">#----》6</span></span><br></pre></td></tr></table></figure><p>汉诺塔问题：有三根柱子，其中一根上从下向上按照大小顺序摆放64个圆盘，需要从一个柱子上按大小顺序摆放到另一个柱子上，一次只能移动一个，而且小圆盘上不能放大圆盘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">n, a, b, c</span>):  <span class="comment"># 把n个圆盘从上经过b移动到c</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        hanoi(n - <span class="number">1</span>, a, c, b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;把第<span class="subst">&#123;n&#125;</span>个圆盘从<span class="subst">&#123;a&#125;</span>移动到<span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line">        hanoi(n - <span class="number">1</span>, b, a, c)</span><br><span class="line"><span class="comment"># 这里只有4个圆盘</span></span><br><span class="line">hanoi(<span class="number">4</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;结果：</span></span><br><span class="line"><span class="string">把第1个圆盘从A移动到B</span></span><br><span class="line"><span class="string">把第2个圆盘从A移动到C</span></span><br><span class="line"><span class="string">把第1个圆盘从B移动到C</span></span><br><span class="line"><span class="string">把第3个圆盘从A移动到B</span></span><br><span class="line"><span class="string">把第1个圆盘从C移动到A</span></span><br><span class="line"><span class="string">把第2个圆盘从C移动到B</span></span><br><span class="line"><span class="string">把第1个圆盘从A移动到B</span></span><br><span class="line"><span class="string">把第4个圆盘从A移动到C</span></span><br><span class="line"><span class="string">把第1个圆盘从B移动到C</span></span><br><span class="line"><span class="string">把第2个圆盘从B移动到A</span></span><br><span class="line"><span class="string">把第1个圆盘从C移动到A</span></span><br><span class="line"><span class="string">把第3个圆盘从B移动到C</span></span><br><span class="line"><span class="string">把第1个圆盘从A移动到B</span></span><br><span class="line"><span class="string">把第2个圆盘从A移动到C</span></span><br><span class="line"><span class="string">把第1个圆盘从B移动到C</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;函数的定义与调用&quot;&gt;&lt;a href=&quot;#函数的定义与调用&quot; class=&quot;headerlink&quot; title=&quot;函数的定义与调用&quot;&gt;&lt;/a&gt;函数的定义与调用&lt;/h1&gt;&lt;h2 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;&lt;/a&gt;函数的定义&lt;/h2&gt;&lt;p&gt;函数是模块化程序设计的基本构成单位,在Python中函数也是对象,使用def语句创建</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="函数的定义与调用" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Opencv写代码没有提示</title>
    <link href="http://example.com/2022/09/08/opencv%E6%B2%A1%E6%9C%89%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA/"/>
    <id>http://example.com/2022/09/08/opencv%E6%B2%A1%E6%9C%89%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA/</id>
    <published>2022-09-08T13:19:31.000Z</published>
    <updated>2022-09-12T09:07:40.889Z</updated>
    
    <content type="html"><![CDATA[<p>今天在写关于Opencv的代码时，没有代码提示，写入代码后也会出现这样的警告。更新Opencv后也不行。</p><p><img src="https://img-blog.csdnimg.cn/51a96f266fba413ead00ef59c0ba0213.png#pic_center" alt="报错"></p><span id="more"></span> <h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>再找了好多方法后，找到一个最简单的办法。这是再PyCharm上解决的方法</p><ol><li><p>打开设置找到项目里的解释器配置；切换到对应的解释器</p><p><img src="https://img-blog.csdnimg.cn/4e337b4318814c75a7618b96b2fb3a70.png#pic_center" alt="项目"></p></li><li><p>打开全部显示</p><p><img src="https://img-blog.csdnimg.cn/1a82f8f4df8f406aa16b2e4252d1f135.png#pic_center" alt="解释器"></p></li><li><p>打开解释器路径</p><p><img src="https://img-blog.csdnimg.cn/4b39dc008b1f40d6ba3b3f078f18ae74.png#pic_center" alt="路径"></p><p>点击左上角的加号</p><p><img src="https://img-blog.csdnimg.cn/b00d462e25a94de2874e7edf5f6ef540.png#pic_center" alt="解释器路径"></p></li><li><p>选中对应解释器下的模块库里的cv2，我这里是anconda虚拟环境，在envs下的解释器里的Lib下的sit-packages里。</p><p><img src="https://img-blog.csdnimg.cn/f593cb8d93da459eb59165d6ce6b6cee.png#pic_center" alt="cv2"></p></li><li><p>最后一路确定，再重启一下就可以了。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在写关于Opencv的代码时，没有代码提示，写入代码后也会出现这样的警告。更新Opencv后也不行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/51a96f266fba413ead00ef59c0ba0213.png#pic_center&quot; alt=&quot;报错&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="问题集锦" scheme="http://example.com/categories/%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="报错" scheme="http://example.com/tags/%E6%8A%A5%E9%94%99/"/>
    
    <category term="opencv" scheme="http://example.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>python基础(五)--序列</title>
    <link href="http://example.com/2022/09/01/Python%E5%9F%BA%E7%A1%80(%E4%BA%94)%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/09/01/Python%E5%9F%BA%E7%A1%80(%E4%BA%94)%E5%BA%8F%E5%88%97/</id>
    <published>2022-09-01T13:23:31.000Z</published>
    <updated>2022-09-12T08:47:04.701Z</updated>
    
    <content type="html"><![CDATA[<p>序列是Python中最基本的数据结构。Python中有六个序列的内置类型，分别是列表、元组、字符串、Unicode字符、buffer对象、xrange对象，最常用的是列表和元组。</p><span id="more"></span> <h1 id="列表和列表推导式"><a href="#列表和列表推导式" class="headerlink" title="列表和列表推导式"></a>列表和列表推导式</h1><p>列表就是用逗号(,)分割的一系列数据用方括号([])括起来,逗号分割的数据称为元素,每个元素都有索引,用来记录元素所在位置,索引从0开始。同时列表的元素也可以是列表。</p><h3 id="列表创建与删除"><a href="#列表创建与删除" class="headerlink" title="列表创建与删除"></a>列表创建与删除</h3><ol><li><p>创建</p><p>列表定义格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表名=[元素<span class="number">1</span>,元素<span class="number">2</span>,...]</span><br></pre></td></tr></table></figure><p>空列表定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">列表名=[]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">列表名=<span class="built_in">list</span>()</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">list2=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">525</span>]</span><br></pre></td></tr></table></figure></li><li><p>删除</p><ul><li><p>根据索引删除某个元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> 列表名[索引]</span><br><span class="line"><span class="comment">#例如:</span></span><br><span class="line">list2=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">525</span>]</span><br><span class="line"><span class="keyword">del</span> list2[<span class="number">2</span>]   <span class="comment">#删除列表中第三个元素</span></span><br><span class="line"><span class="built_in">print</span> list2</span><br><span class="line"><span class="comment">#  结果为list2=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;d&#x27;,525]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>删除列表中某些连续元素格式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> 列表名[[头下标]:[尾下标]]</span><br><span class="line"><span class="comment">#例如:</span></span><br><span class="line">list2=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">525</span>]</span><br><span class="line"><span class="keyword">del</span> list2[<span class="number">2</span>:<span class="number">4</span>]   <span class="comment">#删除列表中第3个到第4个元素</span></span><br><span class="line"><span class="built_in">print</span> list2</span><br><span class="line"><span class="comment">#  结果为list2=[&#x27;a&#x27;,&#x27;b&#x27;,525]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除的是从头下标开始,到尾下标结束之前的内容。省略头下标默认是从0开始，省略尾下标则是默认到结尾处的所有元素。</p></li><li><p>删除列表中所有元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> 列表名[[头下标]:[尾下标]]</span><br><span class="line"><span class="comment">#例如:</span></span><br><span class="line">list2=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">525</span>]</span><br><span class="line"><span class="keyword">del</span> list2[:]   <span class="comment">#删除列表中所有元素</span></span><br><span class="line"><span class="built_in">print</span> list2</span><br><span class="line"><span class="comment">#  结果为list2=[]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>列表的<code>+</code>、<code>*</code>、<code>in</code>运算</p><p>列表的<code>+</code>、<code>*</code>运算与字符串相同，+用于组和列表，<code>*</code>同于重复列表.<code>in</code>用于判断某个元素是否在列表中。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]+[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]    <span class="comment"># 结果为[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,1,2,3]</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]*<span class="number">3</span>                <span class="comment"># 结果为[1,2,3,1,2,3,1,2,3]</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]             <span class="comment"># 结果为True</span></span><br></pre></td></tr></table></figure></li><li><p>列表遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表:</span><br><span class="line">    表达式</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 结果为1 2 3 4 5</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h3><ol><li><p>相关内置函数</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>len(list)</td><td>返回列表长度(即列表元素个数)</td></tr><tr><td>max(list)</td><td>返回列表中最大的元素</td></tr><tr><td>min(list)</td><td>返回列表中最小的元素</td></tr><tr><td>list(sep)</td><td>将元组、字典、集合、字符串转换为列表</td></tr></tbody></table></li><li><p>列表方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>list.append(obj)</td><td>向列表末尾添加对象</td></tr><tr><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>list.extend(sep)</td><td>在列表末尾添加另一个序列的值(用新列表扩展原来的列表)</td></tr><tr><td>list.index(obj)</td><td>返回列表中查找某个值第一个匹配项的索引值</td></tr><tr><td>obj&#x3D;list.pop()</td><td>移除列表中的一个值(默认为最后一个),并返回移除的值</td></tr><tr><td>list.remove(obj)</td><td>移除列表中第一个匹配项</td></tr><tr><td>list.reverse()</td><td>将列表翻转</td></tr><tr><td>list.sort()</td><td>对列表进行排序</td></tr><tr><td>list.clear()</td><td>请空列表</td></tr><tr><td>list.copy()</td><td>复制列表</td></tr></tbody></table></li></ol><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>列表推导式是使用非常简洁的方式来快速生成满足特定需求的列表,代码具有非常强的可读性,运行速度也快.</p><p>格式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表:</span><br><span class="line">    <span class="keyword">if</span> 条件:</span><br><span class="line">        result.append(表达式)</span><br></pre></td></tr></table></figure><h1 id="元组与生成器推导式"><a href="#元组与生成器推导式" class="headerlink" title="元组与生成器推导式"></a>元组与生成器推导式</h1><p>Python元组与列表类似,不同之处在于元组不能修改。元组的访问速度和处理速度更快，元组是在小括号（）中添加元素。</p><h3 id="元组创建"><a href="#元组创建" class="headerlink" title="元组创建"></a>元组创建</h3><ol><li><p>定义格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">元组名 = (元素<span class="number">1</span>,元素<span class="number">2</span>,...)</span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">t1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>空元组定义: <code>元组名=()</code>或者<code>元组名=tuple()</code></p><p>如果元组只有一个元素时,需要在元素后添加逗号,否则括号会被当做运算符。</p></li><li><p>元组访问</p><p>跟列表一样使用索引访问。</p></li><li><p>元组的删除</p><p>元组中的元素不能修改，也不能删除。删除操作只能删除整个元组。使用<code>del</code>删除整个元祖.</p></li><li><p>元组的<code>+</code>、<code>*</code>、<code>in</code>运算</p><p>元组的<code>+</code>、<code>*</code>运算与列表相同，+用于组和元组，<code>*</code>同于重复元组.<code>in</code>用于判断某个元素是否在元组中</p></li><li><p>元组遍历</p><p>元组遍历方式与列表一样</p></li><li><p>元组切片</p><p>元组切片除了不能改变元素的值与列表相同</p></li><li><p>元组内置函数</p><p>元组内置函数中<code>tuple()</code>是将其他列表转换成元组,其他与列表相同.</p></li></ol><h3 id="生成器推导式"><a href="#生成器推导式" class="headerlink" title="生成器推导式"></a>生成器推导式</h3><p>生成器推导格式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(结果 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象 <span class="keyword">if</span> 筛选对象)</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>生成器推导式可以直接获取成生成器对象,生成器可以直接进行for循环,生成器具有惰性机制</li><li>生成器对象既不是列表也不是元组,如果想要让其变成列表或者对象,需要使用list()或者tuple()函数进行转换</li><li>可以使用_ _next_ _()或者内置函数访问生成器对象,但是当所有元素访问完成,如果需要从新访问元素,必须重新创建生成器</li></ul><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>Python中字典是另一种可变容器模型,而且可以存储任意类型对象。</p><h3 id="字典的创建、添加、修改与删除"><a href="#字典的创建、添加、修改与删除" class="headerlink" title="字典的创建、添加、修改与删除"></a>字典的创建、添加、修改与删除</h3><ol><li><p>创建字典</p><p>格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典名 = &#123;<span class="string">&#x27;key1&#x27;</span>:<span class="string">&#x27;value1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,...&#125;</span><br></pre></td></tr></table></figure><p>字典中的每个元素都是‘键(key)值(value)对’,每个键值对使用<code>:</code>分割,每个元素之间用<code>,</code>分割.</p><p>其中键(key)必须是唯一的,如果重复,最后一个的值会替换前边相同键的值。</p></li><li><p>添加与修改字典元素</p><p>格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典名[键] = 值</span><br></pre></td></tr></table></figure><p>当前键已经存在会修改字典中该键原有的值,不存在时,会创建新的键值对.</p></li><li><p>删除字典的元素</p><p>格式:</p><ul><li><p>删除某个键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> 字典名[键]</span><br></pre></td></tr></table></figure></li><li><p>清空字典中所有元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典名.clear()</span><br></pre></td></tr></table></figure></li><li><p>删除字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> 字典名</span><br></pre></td></tr></table></figure></li></ul></li><li><p>内置函数及其方法</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>len(dict)</td><td>返回字典元素的个数,即键的个数</td></tr><tr><td>str(dict)</td><td>输出字典,以可打印的字符串输出</td></tr><tr><td>type(variable)</td><td>返回输入的变量类型</td></tr><tr><td>dict.clear()</td><td>清空字典</td></tr><tr><td>dict.copy()</td><td>复制字典</td></tr><tr><td>dict.fromekey(sep,val)</td><td>以sep中元素为键,val中的元素为值,创建一个新字典</td></tr><tr><td>dict.get(key)</td><td>返回指定键的值,如果键不存在返回None</td></tr><tr><td>dict.items()</td><td>返回字典中的所有键值对</td></tr><tr><td>dict.keys()</td><td>返回字典中的所有键</td></tr><tr><td>dict.update(dict2)</td><td>将dict2合并到dict</td></tr><tr><td>dict.values()</td><td>返回字典中的所有值</td></tr></tbody></table></li></ol><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Python中的集合(set)是一个无序且不重复的序列.</p><h3 id="集合基础知识"><a href="#集合基础知识" class="headerlink" title="集合基础知识"></a>集合基础知识</h3><p>Python的集合也具备数学中集合的特性:确定性、互异性、无序性。</p><p>集合创建格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">集合名 = &#123;value1,value2,...&#125;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">集合名 = <span class="built_in">set</span>(&#123;value1,value2,...&#125;)</span><br></pre></td></tr></table></figure><p>注意:创建空集合必须用set(),而不是{},因为{}使用来创建空字典的。集合中的元素可以是不同的类型（数字、元组、字符串），但不可以是可变元素（列表，集合，字典）。</p><h3 id="集合操作与运算"><a href="#集合操作与运算" class="headerlink" title="集合操作与运算"></a>集合操作与运算</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>len(s)</td><td>返回集合元素个数</td></tr><tr><td>str(s)</td><td>输出集合以字符串表示</td></tr><tr><td>set(value)</td><td>生成可变的集合</td></tr><tr><td>frozenset(value)</td><td>生成不可变集合</td></tr><tr><td>s.copy()</td><td>复制集合</td></tr><tr><td>s.update(t)</td><td>将t中的元素添加到s</td></tr><tr><td>s.add(obj)</td><td>将obj添加到集合s</td></tr><tr><td>s.remove(obj)</td><td>将obj从集合s中删除,如果obj不存在一发异常</td></tr><tr><td>s.discard(obj)</td><td>将obj从集合s中删除,如果obj不存在不影响</td></tr><tr><td>s.pop()</td><td>删除并返回一个不确定元素</td></tr><tr><td>s.clear()</td><td>清空集合</td></tr></tbody></table><h3 id="序列间的区别"><a href="#序列间的区别" class="headerlink" title="序列间的区别"></a>序列间的区别</h3><table><thead><tr><th>特征\类别</th><th>列表</th><th>元组</th><th>字典</th><th>集合</th></tr></thead><tbody><tr><td>英文</td><td>list</td><td>tuple</td><td>dict</td><td>set</td></tr><tr><td>可读</td><td>读写</td><td>只可读</td><td>读写</td><td>读写</td></tr><tr><td>是否重复</td><td>是</td><td>是</td><td>是(键不可重复)</td><td>否</td></tr><tr><td>存储</td><td>值</td><td>值</td><td>键值对</td><td>键(不可重复)</td></tr><tr><td>是否有序</td><td>有序</td><td>有序</td><td>无序</td><td>无序</td></tr><tr><td>添加</td><td>append()</td><td>不能添加</td><td>d[key]&#x3D;value</td><td>add()</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;序列是Python中最基本的数据结构。Python中有六个序列的内置类型，分别是列表、元组、字符串、Unicode字符、buffer对象、xrange对象，最常用的是列表和元组。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="序列" scheme="http://example.com/tags/%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>python基础(四)--程序控制结构</title>
    <link href="http://example.com/2022/09/01/Python%E5%9F%BA%E7%A1%80(%E5%9B%9B)%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/09/01/Python%E5%9F%BA%E7%A1%80(%E5%9B%9B)%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</id>
    <published>2022-09-01T13:23:31.000Z</published>
    <updated>2022-09-01T13:03:22.656Z</updated>
    
    <content type="html"><![CDATA[<p>Python语言也是结构化程序设计语言,其基本程序结构有三种:顺序结构、选择结构（分支结构）、循环结构。</p><ul><li>循环结构：即程序从上至下逐条语句执行。</li><li>选择结构：指程序在运行过程中根据条件有选择的执行一些语句。</li><li>循环结构：是为解决一些实际问题中具有规律性的重复操作的工作，为反复执行某些语句而设置的一种程序结构。</li></ul><span id="more"></span>  <h1 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h1><p>Python中的三元运算符,即条件表达式,其语法如下:</p><p><code>表达式 if 表达式2 else 表达式3</code></p><p>其中表达式2结果为True(非0)或者Flase(0),为True(非0)时,整个条件表达式的值为表达式1的值,为False时整个条件表达式的值为表达式2的值。</p><p>例：输入3个整数，输出3个数最大的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数:&#x27;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数:&#x27;</span>))</span><br><span class="line">c = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数:&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span> = (a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b) <span class="keyword">if</span> (a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b) &gt; c <span class="keyword">else</span> c</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span>,<span class="subst">&#123;b&#125;</span>,<span class="subst">&#123;c&#125;</span>中最大的数为<span class="subst">&#123;<span class="built_in">max</span>&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><p>用if语句可以构成选择结构。他根据条件进行判断，以决定执行某个分支程序段。if语句有三种形式，分别是if形式，if…else…形式,if…elif…else形式。</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if语句形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">语句块</span><br></pre></td></tr></table></figure><p>如果表达式的值为真(或非0),则执行语句块,否则不执行该语句块。</p><p>例:输入一个整数,判断该整数是否在1~100内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入整数:&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n&#125;</span>是在1到100的整数&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>if后的表达式可以是任意合法的表达式;</li><li>若if只控制一条语句,则语句可以与if同一行;</li><li>若if控制多条语句,则要把这组语句同一缩进。</li></ul><h2 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h2><p>if…else语句形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">语句块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">语句块</span><br></pre></td></tr></table></figure><ul><li>只有if后有表达式,else后没有表达式,只有受其控制的语句块</li></ul><h2 id="if…elif…else语句"><a href="#if…elif…else语句" class="headerlink" title="if…elif…else语句"></a>if…elif…else语句</h2><p>if…elif…else语句形式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">语句块</span><br><span class="line"><span class="keyword">elif</span> 表达式<span class="number">1</span>:</span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">elif</span>  表达式n:</span><br><span class="line">    语句块n</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">语句块</span><br></pre></td></tr></table></figure><ul><li>依次判断表达式的值,如果某个表达式为真,则执行对应语句块,然后跳出if语句之外执行程序。</li></ul><h2 id="选择结构嵌套"><a href="#选择结构嵌套" class="headerlink" title="选择结构嵌套"></a>选择结构嵌套</h2><p>选择结构的嵌套是指在if或else分支语句中又包含了if语句或if…else或if…elif…else语句。分为内层语句和外层语句。</p><p>语句格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> 表达式<span class="number">2</span>:</span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">语句块<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">语句块<span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环结构是为了当程序再一次运行中，其中某些语句需要被反复执行多次，又称为重复结构。</p><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>多用于语句的循环次数未知的程序中，格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式:</span><br><span class="line">    循环语句组</span><br><span class="line">[<span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">else</span>语句体]</span><br></pre></td></tr></table></figure><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>是程序实现循环结构的常用语句之一，尤其处理已知语句的循环次数的程序中应用较多，一般用循环变量依次取出序列中的元素而实现的控制。格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    循环体语句组</span><br><span class="line">[<span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">else</span>语句组]</span><br></pre></td></tr></table></figure><h2 id="continue和break语句"><a href="#continue和break语句" class="headerlink" title="continue和break语句"></a>continue和break语句</h2><p>在循环语句中,如果想要在循环条件仍然满足的情况下提前退出循环语句使用<code>break</code>语句，如果想要结束某次循环进入下一轮而不是完全退出循环语句时，可使用<code>continue</code>语句实现。</p><p><code>pass</code>语句是空语句,是为了保证程序结构的完整性,可以放在任何结构或函数中。pass不做任何事请，一般用作站位语句。</p><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>循环结构和分支结构一样也可以进行嵌套，就是把一个完整的循环体系嵌入另一个循环体中。</p><p>&#x3D;&#x3D;正常情况下：应先执行内层的循环体操作，然后是外层循环。例如：对于双重循环，内层循环执行次数为：内层次数*外层循环。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;各种循环可以互相嵌套，自由组合。但是各循环必须完整包含，相互间绝对不允许有交叉现象。&#x3D;&#x3D;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python语言也是结构化程序设计语言,其基本程序结构有三种:顺序结构、选择结构（分支结构）、循环结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环结构：即程序从上至下逐条语句执行。&lt;/li&gt;
&lt;li&gt;选择结构：指程序在运行过程中根据条件有选择的执行一些语句。&lt;/li&gt;
&lt;li&gt;循环结构：是为解决一些实际问题中具有规律性的重复操作的工作，为反复执行某些语句而设置的一种程序结构。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="程序控制结构" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>python基础(三)--变量与运算符</title>
    <link href="http://example.com/2022/08/26/python%E5%9F%BA%E7%A1%80(%E4%B8%89)%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2022/08/26/python%E5%9F%BA%E7%A1%80(%E4%B8%89)%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-08-26T13:23:31.000Z</published>
    <updated>2022-08-27T05:47:07.878Z</updated>
    
    <content type="html"><![CDATA[<p>在程序中用到的数据通常是用变量、常量或将这些常量或变量用某些运算符连接起来形成的表达式来体现。</p><span id="more"></span><h1 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h1><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是在程序中有特定含义的一组字符，比如类名、对象名、属性名、函数名等。</p><p>在Python中，标识符命名规则如下：</p><ul><li><p>长度无限制。</p></li><li><p>标识符不能使用Python中的关键字(保留字).</p></li><li><p>字母大小写敏感.</p></li><li><p>标识符可以由字母、下划线以及Unicode编码中的非英文字母开头，后面的字符可以是上述任意字符也可以是数字。</p></li></ul><p>Python3关键字：</p><table><thead><tr><th align="center">False</th><th align="center">class</th><th align="center">from</th><th align="center">or</th><th align="center">and</th><th align="center">None</th></tr></thead><tbody><tr><td align="center">continue</td><td align="center">pass</td><td align="center">True</td><td align="center">def</td><td align="center">finally</td><td align="center">raise</td></tr><tr><td align="center">global</td><td align="center">try</td><td align="center">import</td><td align="center">return</td><td align="center">with</td><td align="center">await</td></tr><tr><td align="center">in</td><td align="center">except</td><td align="center">assert</td><td align="center">else</td><td align="center">for</td><td align="center">not</td></tr><tr><td align="center">async</td><td align="center">yield</td><td align="center">lambda</td><td align="center">if</td><td align="center">as</td><td align="center">while</td></tr><tr><td align="center">nonlocal</td><td align="center">del</td><td align="center">break</td><td align="center">elif</td><td align="center">is</td><td align="center"></td></tr></tbody></table><p>一般标识符命名规定约定：</p><ul><li>小驼峰式命名法，如：userName。</li><li>大驼峰式命名法，如：UserName。</li><li>下划线连接法，如：user_name。</li><li>不要使用内置的类名，函数名，以及内置的异常名。</li><li>不要在名字开头结尾都用下划线。</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在Python中，将一个值或对象用一个赋值运算符（&#x3D;）赋值给一个标识符，则该标识符即为变量的名字，需要时可对变量名重新复制。Python不需要先声明变量为某种类型，可直接使用。</p><p>变量赋值：</p><ul><li>单个变量赋值：标识符&#x3D;值</li><li>多变量赋同一个值：标识符1&#x3D;标识符2&#x3D;值</li><li>多个变量赋不同值：标识符1，标识符2&#x3D;值1，值2</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;哈哈钟&#x27;</span></span><br><span class="line">age  = <span class="number">21</span></span><br><span class="line">width = <span class="number">65.3</span></span><br><span class="line"><span class="built_in">print</span>(name,age,width)</span><br><span class="line"><span class="comment"># 也可以这样赋值</span></span><br><span class="line">name , age , width = <span class="string">&#x27;哈哈钟&#x27;</span> , <span class="number">21</span> , <span class="number">65.3</span></span><br><span class="line"><span class="built_in">print</span>(name,age,width)</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在Python中,一个字面意义上的常量的例子是如同0、2、3.14、6.57e-3这样的数，或者字符串或者布尔值。这些数据在程序中按字面意思的值进行处理，这些值通常情况不能改变，所以这些被称为字面意义上的常量。通常把标识符大写当最常量使用。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure><h1 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h1><p>一个表达式分为运算符和操作数，如1+2,+就是运算符，1和2就是操作数。在Python中表达式可以作为语句，但是表达式结果存储需要借助变量。</p><h3 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h3><table><thead><tr><th>运算符</th><th>名称</th><th>举例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单赋值</td><td>c &#x3D;a + b将a + b的值赋给c</td></tr><tr><td>+&#x3D;</td><td>加法赋值</td><td>c +&#x3D; a相当于c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值</td><td>c -&#x3D; a相当于c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值</td><td>c *&#x3D; a相当于c &#x3D; c  * a</td></tr><tr><td>%&#x3D;</td><td>取余赋值</td><td>c %&#x3D; a相当于c &#x3D; c % a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值</td><td>c &#x2F;&#x3D; a相当于c &#x3D; c &#x2F; a</td></tr><tr><td>**&#x3D;</td><td>幂赋值</td><td>c * * &#x3D; a相当于c&#x3D;c  * * a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整赋值</td><td>c &#x2F;&#x2F;&#x3D; a相当于c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>+</td><td>加</td><td>3 + 5得到8，’a’+’b’得到’ab’</td></tr><tr><td>-</td><td>减</td><td>-2.5得到负数，50-24得到26</td></tr><tr><td>*</td><td>乘</td><td>2 * 3得到3，’ha’ * 3得到’hahaha’</td></tr><tr><td>**</td><td>幂</td><td>3 ** 2 得到9</td></tr><tr><td>&#x2F;</td><td>除</td><td>4&#x2F;3得到1(整数除法得到整数)，4.0&#x2F;3或4&#x2F;3.0得到1.333333333</td></tr><tr><td>&#x2F;&#x2F;</td><td>整除</td><td>4 &#x2F;&#x2F; 3.0 得到1.0</td></tr><tr><td>%</td><td>取余</td><td>4%3得到1，4.0%3得到1.0</td></tr><tr><td>&lt;</td><td>小于</td><td>3&lt;5返回True，5&lt;3返回False</td></tr><tr><td>&gt;</td><td>大于</td><td>5&gt;3返回True，3&gt;5返回False</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td><td>2 &#x3D;&#x3D; 2返回True,，str’ &#x3D;&#x3D; ‘Str’返回False，’str’ &#x3D;&#x3D; ‘str’返回True</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>2 &gt;&#x3D; 2返回True，1 &gt;&#x3D; 2返回False</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>2 &lt;&#x3D; 2返回True，4 &lt;&#x3D; 2返回False</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>‘str’ !&#x3D; ‘Str返回True，2 !&#x3D; 2返回False</td></tr><tr><td>not</td><td>布尔‘非’</td><td>not True返回False</td></tr><tr><td>and</td><td>布尔‘与’</td><td>True and False返回False</td></tr><tr><td>or</td><td>布尔‘或’</td><td>True or False返回True</td></tr></tbody></table><h3 id="运算符优先级-由高到低"><a href="#运算符优先级-由高到低" class="headerlink" title="运算符优先级(由高到低)"></a>运算符优先级(由高到低)</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>f()</td><td>函数调用</td></tr><tr><td>x[index:index]</td><td>切片</td></tr><tr><td>x[index]</td><td>索引</td></tr><tr><td>x.attribute</td><td>属性</td></tr><tr><td>**</td><td>幂</td></tr><tr><td>~x</td><td>按位翻转</td></tr><tr><td>+x 、-x</td><td>正负号</td></tr><tr><td>*、&#x2F;、%、&#x2F;&#x2F;</td><td>乘除、取余、取整</td></tr><tr><td>+、-</td><td>加、减</td></tr><tr><td>&lt;&lt;、&gt;&gt;</td><td>移位</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>&lt;、&lt;&#x3D;、&#x3D;&#x3D;、&gt;&#x3D;、&gt;、!&#x3D;</td><td>比较</td></tr><tr><td>&#x3D;、%&#x3D;、&#x2F;&#x3D;、&#x2F;&#x2F;&#x3D;、-&#x3D;、+&#x3D;、*&#x3D; 、**&#x3D;</td><td>赋值</td></tr><tr><td>is 、is not</td><td>同一性测试</td></tr><tr><td>in 、not in</td><td>成员测试</td></tr><tr><td>not x</td><td>布尔‘非’</td></tr><tr><td>and</td><td>布尔‘与’</td></tr><tr><td>or</td><td>or</td></tr><tr><td>lambda</td><td>Lambda表达式</td></tr></tbody></table><h3 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>range([start],stop[,step])</td><td>产生一个序列，默认从0开始，含头不含尾，step为分隔符</td></tr><tr><td>round(x[,n])</td><td>四舍五入</td></tr><tr><td>sum()</td><td>求和</td></tr><tr><td>max()</td><td>求最大值</td></tr><tr><td>min()</td><td>求最小值</td></tr><tr><td>sorted(iterable[cmp[,key[,reverse]]])</td><td>进行排序</td></tr><tr><td>len()</td><td>返回集合长度</td></tr><tr><td>map(function,iterable,…)</td><td>遍历每个元素，执行function函数</td></tr><tr><td>type(object)</td><td>返回对象类型</td></tr><tr><td>pow(x,y)</td><td>返回x的y次幂</td></tr><tr><td>oct(x)</td><td>转换为八进制</td></tr><tr><td>hex(x)</td><td>转换为十六进制</td></tr><tr><td>chr(x)</td><td>转换为对应的ASCII字符</td></tr><tr><td>bin(x)</td><td>转换为二进制</td></tr><tr><td>filter(function,iterable)</td><td>构造一个序列</td></tr><tr><td>iter(o[,sentine])</td><td>生成一个对象的迭代器，第二个参数为分隔符</td></tr><tr><td>zip([iterable,…])</td><td>用于将可迭代对象的元素打包成一个个元组，然后返回这些元组的列表</td></tr><tr><td>open(name[,mode[,buffering]])</td><td>打开文件，name为文件名称，mode为打开权限，buffering表示是否缓冲</td></tr><tr><td>print()</td><td>输出</td></tr><tr><td>input()</td><td>输入</td></tr><tr><td>format()</td><td>格式化输出（在Python基础（一）中具体讲解）</td></tr><tr><td>类型转换、创建函数</td><td>在Python基础（二）中有具体讲解</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;在程序中用到的数据通常是用变量、常量或将这些常量或变量用某些运算符连接起来形成的表达式来体现。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="变量与运算" scheme="http://example.com/tags/%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>python基础(二)--数据类型</title>
    <link href="http://example.com/2022/08/20/python%E5%9F%BA%E7%A1%80(%E4%BA%8C)%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2022/08/20/python%E5%9F%BA%E7%A1%80(%E4%BA%8C)%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-08-20T13:19:31.000Z</published>
    <updated>2022-08-20T10:33:45.371Z</updated>
    
    <content type="html"><![CDATA[<p>python3的标准数据类型有Number(数字)、String(字符串)、List(列表)、Tuple(元组)、Set(集合)、Dictionary(字典)。</p><span id="more"></span><h1 id="一、数值类型"><a href="#一、数值类型" class="headerlink" title="一、数值类型"></a>一、数值类型</h1><p>python中数值类型有四种：int(整形)、float(浮点型)、bool(布尔型)、complex(复数型)</p><ul><li>int: 只有一种长整型整数. 如:a&#x3D;23</li><li>float: 小数 如: b&#x3D;23.23</li><li>bool: 布尔型的值只有True和False两个关键字,True的值为1,false的值为0.如:c&#x3D;True</li><li>complex: 存放的是一对浮点数,一个实数和一个虚数表示复数.如:d&#x3D;2.5+i</li></ul><h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><p>python中字符串用单引号(‘)、双引号(“)、三引号(‘’’或”””)括起来,也可以使用反斜杠\转义特殊字符串。</p><h3 id="1-字符串截取（切片）"><a href="#1-字符串截取（切片）" class="headerlink" title="1.字符串截取（切片）"></a>1.字符串截取（切片）</h3><p>语法格式： <code>变量[头下标:尾下标[:间隔数]]</code><br>表示截取字符串从头下标(包括头下标字符)开始到尾下标之前(不包括尾下标的字符)的字符.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;hahazhong&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出字符串--&gt;hahazhong</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])  <span class="comment"># 输出字符串中第一个字符--&gt;h</span></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">1</span>])  <span class="comment"># 输出字符串中最后一个字符--&gt;g</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:-<span class="number">1</span>])  <span class="comment"># 输出字符串中第二个字符到倒数第二个的字符--&gt;ahazhon</span></span><br><span class="line"><span class="built_in">print</span>(a[:-<span class="number">1</span>])  <span class="comment"># 输出字符串第一个到倒数倒数第二个字符--&gt;hahazhon</span></span><br><span class="line"><span class="built_in">print</span>(a[::-<span class="number">1</span>])  <span class="comment"># 逆向截取字符串--&gt;gnohzahah</span></span><br><span class="line"><span class="built_in">print</span>(a[::<span class="number">2</span>])  <span class="comment"># 输出奇数位的字符串,从左到右每次间隔1个字符取字符--&gt;hhzog</span></span><br></pre></td></tr></table></figure><h3 id="2-字符串更新"><a href="#2-字符串更新" class="headerlink" title="2.字符串更新"></a>2.字符串更新</h3><p>在python中字符串是不可变类型,无法直接改变字符串某一位字符.如果要改变字符串的元素需要对字符串重新复制.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将字符串hahazhong改为Hahazhong:</span></span><br><span class="line">a = <span class="string">&#x27;hahazhong&#x27;</span></span><br><span class="line">a = <span class="string">&#x27;H&#x27;</span> + a[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># --&gt;Hahazhong</span></span><br><span class="line">a = a.replace(<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 将所有的&#x27;h&#x27;换为&#x27;H&#x27;--&gt;HaHazHong</span></span><br></pre></td></tr></table></figure><h3 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3.转义字符"></a>3.转义字符</h3><table><thead><tr><th align="center">转义字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">续行符</td></tr><tr><td align="center">\</td><td align="center">反斜杠</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">\a</td><td align="center">响铃</td></tr><tr><td align="center">\b</td><td align="center">退格</td></tr><tr><td align="center">\e</td><td align="center">转义</td></tr><tr><td align="center">\000</td><td align="center">空</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\v</td><td align="center">纵向制表符</td></tr><tr><td align="center">\t</td><td align="center">横向制表符</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\f</td><td align="center">换页</td></tr><tr><td align="center">\yyy</td><td align="center">八进制数yyy代表的字符</td></tr><tr><td align="center">\xyy</td><td align="center">十六进制yy代表的字符</td></tr><tr><td align="center">\other</td><td align="center">其他字符以普通格式输出</td></tr></tbody></table><h3 id="4-常用函数"><a href="#4-常用函数" class="headerlink" title="4.常用函数"></a>4.常用函数</h3><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">capitalize()</td><td align="left">将字符串第一个字符转换为大写</td></tr><tr><td align="left">find(str,beg&#x3D;0,end&#x3D;len(string)</td><td align="left">检测str是否在字符串中,,beg和end指定检测范围,如果存在返回索引,不存在则返回-1</td></tr><tr><td align="left">len(string)</td><td align="left">返回字符串的长度</td></tr><tr><td align="left">join(seq)</td><td align="left">以指定字符串为分隔符,将seq中所有元素合并为一个新字符串</td></tr><tr><td align="left">lower()</td><td align="left">将字符串中的大写字符替换为小写</td></tr><tr><td align="left">upper()</td><td align="left">将字符串中的小写字符替换为大写</td></tr><tr><td align="left">lstrip()</td><td align="left">截掉字符串左边的空格</td></tr><tr><td align="left">rstrip()</td><td align="left">删除字符串右边的空格</td></tr><tr><td align="left">strip([string])</td><td align="left">在字符串上执行lstrip()和rstrip()函数</td></tr><tr><td align="left">max(str)</td><td align="left">返回str中最大的字母</td></tr><tr><td align="left">min(str)</td><td align="left">返回str中最小的字母</td></tr><tr><td align="left">replace(old,new[,max])</td><td align="left">将字符串中的某一个元素替换成新元素,如果指定max,则替换不超过max</td></tr><tr><td align="left">zfill(width)</td><td align="left">返回长度为width的字符串,源字符串右对齐,前面填充0</td></tr></tbody></table><h1 id="三、布尔类型"><a href="#三、布尔类型" class="headerlink" title="三、布尔类型"></a>三、布尔类型</h1><p>python中bool类型可以和数值类型进行混合运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> + <span class="number">5</span>)  <span class="comment"># --&gt;6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span> + <span class="number">2</span>)  <span class="comment"># --&gt;2</span></span><br></pre></td></tr></table></figure><h1 id="四、空值None"><a href="#四、空值None" class="headerlink" title="四、空值None"></a>四、空值None</h1><p>在python中None是一个特殊的常量.None有自己的类型NoneType,None主要判断对象是否为空值.<br>None和False不同,None不是0;不是空字符串;None和其他数据类型比较永远返回False;可以将None赋值给任意变量,但是无法创建其他的NoneType对象.  </p><h1 id="五、数据类型转换"><a href="#五、数据类型转换" class="headerlink" title="五、数据类型转换"></a>五、数据类型转换</h1><p>使用内置函数对数据类型进行转换:</p><table><thead><tr><th align="left">函数格式</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">int(x[,base])</td><td align="left">int(‘8.5’)将字符串’8.5’转换为8<br/>int(‘12345’,8)将八进制12345转换为十进制5349</td><td align="left">将数字类型转换为整数类型</td></tr><tr><td align="left">float(x)</td><td align="left">float(1)–&gt;1.0<br/>float(‘1’)–&gt;1.0</td><td align="left">转换为浮点数,不足的位数用0补齐</td></tr><tr><td align="left">complex(real,imag)</td><td align="left">complex(‘1’)<br/>complex(1,2)</td><td align="left">转换为复数,第一个参数可以为string类型和数字类型,第二个只能为数字,默认为0</td></tr><tr><td align="left">str(x)</td><td align="left">str(1)</td><td align="left">转化为字符串</td></tr><tr><td align="left">repr(x)</td><td align="left">repr(Object)</td><td align="left">返回一个对象的String类型</td></tr><tr><td align="left">eval(str)</td><td align="left">eavl(‘12+13’)</td><td align="left">执行字符串表达式,并返回结果</td></tr><tr><td align="left">list(s)</td><td align="left">list((1,2,3,4))</td><td align="left">将序列转化为列表</td></tr><tr><td align="left">tuple(sep)</td><td align="left">tuple([1,2,3,4])</td><td align="left">将序列转换为元组</td></tr><tr><td align="left">set(s)</td><td align="left">set((1,2,3,4,5,4,5))</td><td align="left">将一个可迭代对象转换为集合,并且去重复,返回结果</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;python3的标准数据类型有Number(数字)、String(字符串)、List(列表)、Tuple(元组)、Set(集合)、Dictionary(字典)。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="数据类型" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>python基础(一)--标准输入输出</title>
    <link href="http://example.com/2022/08/17/python%E5%9F%BA%E7%A1%80(%E4%B8%80)%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2022/08/17/python%E5%9F%BA%E7%A1%80(%E4%B8%80)%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2022-08-17T13:19:31.000Z</published>
    <updated>2022-08-17T14:29:09.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h1><p><code>input()</code>函数被称为格式输入语言,即按照用户指定的格式从键盘把数据输入到指定变量中</p><span id="more"></span><p>例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">input</span>(<span class="string">&#x27;请输入年龄:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)<span class="comment">#--&gt;请输入年龄:88</span></span><br><span class="line">        <span class="comment">#   88</span></span><br></pre></td></tr></table></figure><p>也可以使用<code>eavl()</code>函数和<code>input()</code>函数结合,实现一次性接受多个数据,给多个变量赋值。并且会把数据转换成对应的格式.<br>例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name, age = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入姓名,年龄:&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(name,age)<span class="comment">#--&gt;请输入姓名,年龄:&#x27;张三&#x27;,88</span></span><br><span class="line">               <span class="comment">#   张三 88</span></span><br></pre></td></tr></table></figure><h1 id="标准输出函数"><a href="#标准输出函数" class="headerlink" title="标准输出函数"></a>标准输出函数</h1><p><code>print()</code>函数可以向控制台输出一个或者多个字符.<br>例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([表达式<span class="number">1</span>,表达式<span class="number">2</span>,...,表达式n],[sep=分隔符],[end=结束符])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, sep=<span class="string">&#x27;.&#x27;</span>, end=<span class="string">&#x27;。&#x27;</span>)  <span class="comment">#--&gt;a.b。</span></span><br></pre></td></tr></table></figure><h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p><code>格式化字符串%(表达式,...,表达式n)</code></p><ol><li><code>%[[+/-]n]c</code>:输出ASCII字符.等价于<code>chr()</code>函数.长度为n位(n小于实际长度时,按实际长度输出),+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%c&#x27;</span>%<span class="string">&#x27;A&#x27;</span>)  <span class="comment">#--&gt; A</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%c%c%c&#x27;</span> % (<span class="string">&#x27;A&#x27;</span>, <span class="number">66</span>, <span class="literal">True</span>+<span class="number">66</span>))  <span class="comment">#--&gt;ABC</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%c%c%+6c&#x27;</span> % (<span class="string">&#x27;A&#x27;</span>, <span class="number">66</span>, <span class="literal">True</span>+<span class="number">66</span>))  <span class="comment">#--&gt;AB     C</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%6c%c%c&#x27;</span> % (<span class="string">&#x27;A&#x27;</span>, <span class="number">66</span>, <span class="literal">True</span>+<span class="number">66</span>))  <span class="comment">#--&gt;     ABC</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%c%-6c%c&#x27;</span> % (<span class="string">&#x27;A&#x27;</span>, <span class="number">66</span>, <span class="literal">True</span>+<span class="number">66</span>))  <span class="comment">#--&gt;AB     C</span></span><br></pre></td></tr></table></figure></li><li><code>%%</code>:输出%<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%c%%%c%%%c&#x27;</span> % (<span class="string">&#x27;A&#x27;</span>, <span class="number">66</span>, <span class="literal">True</span>+<span class="number">66</span>))  <span class="comment">#--&gt;A%B%C</span></span><br></pre></td></tr></table></figure></li><li><code>%[[+/-]n]s</code>:输出字符串,等价于<code>str()</code>函数,长度为n位(n小于实际长度时,按实际长度输出),+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%c%8s%2c&#x27;</span> % (<span class="number">65</span>, <span class="string">&#x27;python&#x27;</span>, <span class="number">66</span>))  <span class="comment">#--&gt;A  python B</span></span><br></pre></td></tr></table></figure></li><li><code>%[[+/-]n]r</code>:输出表达式,等价于<code>repr()</code>函数,长度为n位(n小于实际长度时,按实际长度输出),+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%r*%r*%r&#x27;</span> % (<span class="number">65</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;B&#x27;</span>))  <span class="comment">#--&gt;65*&#x27;python&#x27;*&#x27;B&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%r%r%r&#x27;</span> % (<span class="number">65</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;x*y&#x27;</span>))  <span class="comment">#--&gt;65&#x27;python&#x27;&#x27;x*y&#x27;</span></span><br></pre></td></tr></table></figure></li><li><code>%[[+/-]n]d</code>、<code>%[[+/-]n]i</code>、<code>%[[+/-]n]u</code>:输出十进制整数,长度为n位(n小于实际长度时,按实际长度输出),+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%c%8d%8i%8u%8c&#x27;</span> % (<span class="number">65</span>, <span class="number">12.34</span>, <span class="number">12.34</span>, <span class="number">12.34</span>, <span class="number">66</span>))  <span class="comment">#--&gt;print(&#x27;%c%8d%8i%8u%8c&#x27; % (65, 12.34, 12.34, 12.34, 66))</span></span><br></pre></td></tr></table></figure></li><li><code>%[[+/-]n]o</code>:输出八进制整数,长度为n位(n小于实际长度时,按实际长度输出),+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%o&#x27;</span> % <span class="number">22</span>)  <span class="comment">#--&gt;26</span></span><br></pre></td></tr></table></figure></li><li><code>%[[+/-]n]x</code>、<code>%[[+/-]n]X</code>:输出八进制整数,长度为n位(n小于实际长度时,按实际长度输出),+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%x%5X&#x27;</span> % (<span class="number">64</span>, <span class="number">64</span>))  <span class="comment">#--&gt;40   40</span></span><br></pre></td></tr></table></figure></li><li><code>%[[+/-]n.m]e</code>、<code>%[[+/-]n.m]E</code>:输出实数,长度为n位(n小于实际长度时,按实际长度输出),m为小数位数,+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%e%20.1E&#x27;</span> % (<span class="number">64</span>, <span class="number">64.58</span>))  <span class="comment">#--&gt;6.400000e+01             6.5E+01</span></span><br></pre></td></tr></table></figure></li><li><code>%[[+/-]n.m]f</code>、<code>%[[+/-]n.m]F</code>:输出实数,采用科学计数,长度为n位(n小于实际长度时,按实际长度输出),m为小数位数,+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%f%20.1F&#x27;</span> % (<span class="number">64</span>, <span class="number">64.58</span>))  <span class="comment">#--&gt;64.000000                64.6</span></span><br></pre></td></tr></table></figure></li><li><code>%[[+/-]n.m]g</code>、<code>%[[+/-]n.m]G</code>:输出实数,根据数据大小采用e(E)或f(F),长度为n位(n小于实际长度时,按实际长度输出),m为小数位数,+表示右对齐(默认,可省略),-(左对齐).<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%g%20.8G&#x27;</span> % (<span class="number">64</span>, <span class="number">64.58</span>))  <span class="comment">#--&gt;64               6E+01</span></span><br></pre></td></tr></table></figure></li><li><code>%Y</code>、<code>%m</code>、<code>%d</code>、<code>%H</code>、<code>%M</code>、<code>%s</code>:输出年月日时分秒.<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())))  <span class="comment">#--&gt;2022-08-17 21:14:22 </span></span><br></pre></td></tr></table></figure><h3 id="format-格式化输出"><a href="#format-格式化输出" class="headerlink" title="format()格式化输出"></a>format()格式化输出</h3></li><li>format()函数的一般格式为:<code>format(表达式[,格式化字符串])</code><br>格式化字符串:</li></ol><ul><li>[n]c –&gt; ASCII值的字符</li><li>%    –&gt; 百分号</li><li>d&#x2F;b&#x2F;o&#x2F;x&#x2F;X –&gt; 十、二、八、十六进制整数</li><li>f&#x2F;F –&gt; 实数(科学计数法)</li><li>e&#x2F;E –&gt; 实数(定点小数)</li><li>填充字符(&#x3D;: 填充字符位于符号和数字之间;&lt;左对齐,&gt;右对齐,^居中)</li><li>省略格式字符串 –&gt; 等价于str(表达式)<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">65</span>, <span class="string">&#x27;^5c&#x27;</span>))   <span class="comment">#--&gt;  A  </span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><code>格式化字符串.format(表达式1,...,表达式n)</code></li></ol><ul><li>格式字符串:包括普通字符和格式字符</li><li>普通字符:按照原样输出</li><li>格式字符的格式:<code>&#123;[序号/键[: ][格式字符]]&#125;</code>序号(0,1,2…)表示格式顺序(可写可不写,可颠倒顺序),键用于指向该键的数据.格式字符与<code>format()</code>类似<br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello,&#123;&#125;,&#123;&#125;,&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">88</span>, <span class="number">65.3</span>, <span class="string">&#x27;你好&#x27;</span>)) <span class="comment">#--&gt; hello,88,65.3,你好</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello,&#123;x&#125;,&#123;y&#125;,&#123;z&#125;&#x27;</span>.<span class="built_in">format</span>(x=<span class="number">88</span>, y=<span class="number">65.3</span>, z=<span class="string">&#x27;你好&#x27;</span>)) <span class="comment">#--&gt; hello,88,65.3,你好</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello,&#123;:c&#125;,&#123;:f&#125;,&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">88</span>, <span class="number">65.3</span>, <span class="string">&#x27;你好&#x27;</span>)) <span class="comment">#--&gt; hello,X,65.300000,你好</span></span><br></pre></td></tr></table></figure><h3 id="格式化输出f’’"><a href="#格式化输出f’’" class="headerlink" title="格式化输出f’’"></a>格式化输出f’’</h3>python3.6以后可以支持 <code>f&#39;&#123;格式字符串:[格式字符]&#125;&#39;</code><br>例:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;abc<span class="subst">&#123;<span class="number">88</span>:7c&#125;</span><span class="subst">&#123;<span class="number">68.123</span>:15e&#125;</span>&#x27;</span>)  <span class="comment">#--&gt; abc      X   6.812300e+01</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;标准输入&quot;&gt;&lt;a href=&quot;#标准输入&quot; class=&quot;headerlink&quot; title=&quot;标准输入&quot;&gt;&lt;/a&gt;标准输入&lt;/h1&gt;&lt;p&gt;&lt;code&gt;input()&lt;/code&gt;函数被称为格式输入语言,即按照用户指定的格式从键盘把数据输入到指定变量中&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="语言基础" scheme="http://example.com/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>版本控制Git远程常用命令</title>
    <link href="http://example.com/2022/05/22/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/22/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-22T13:19:31.000Z</published>
    <updated>2022-05-24T09:33:18.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化远程仓库"><a href="#初始化远程仓库" class="headerlink" title="初始化远程仓库"></a>初始化远程仓库</h2><h4 id="克隆版本库"><a href="#克隆版本库" class="headerlink" title="克隆版本库"></a>克隆版本库</h4><p><code>git clone &lt; url &gt;</code></p><h4 id="添加远程版本库的别名"><a href="#添加远程版本库的别名" class="headerlink" title="添加远程版本库的别名"></a>添加远程版本库的别名</h4><p><code>git remote add &lt;别名&gt;&lt; url &gt;</code></p><h4 id="删除远程版本库的别名"><a href="#删除远程版本库的别名" class="headerlink" title="删除远程版本库的别名"></a>删除远程版本库的别名</h4><p><code>git remote rm &lt;别名&gt;</code></p><h4 id="创建一个无本地分支的库"><a href="#创建一个无本地分支的库" class="headerlink" title="创建一个无本地分支的库"></a>创建一个无本地分支的库</h4><p><code>git init -bare</code></p><span id="more"></span><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><p>列出远程分支: <code>git branch -r</code><br>删除远程库中不存在的分支: <code>git rremote prune origin</code></p><h4 id="获取远程库"><a href="#获取远程库" class="headerlink" title="获取远程库"></a>获取远程库</h4><p>获取但是不合并: <code>git fetch &lt;远程版本库&gt;</code><br>获取并合并到当前本地分支: <code>git pull</code>或者<code>git pull &lt;远程仓库&gt;&lt;远程仓库分支&gt;</code></p><h4 id="推送远程库"><a href="#推送远程库" class="headerlink" title="推送远程库"></a>推送远程库</h4><p><code>git push &lt;远程仓库&gt;&lt;远程分支&gt;</code></p><h4 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h4><p>branch关联: <code>git branch -u &lt;远程仓库&gt;&lt;分支&gt;</code><br>push关联: <code>git push &lt;远程仓库&gt;&lt;分支&gt;</code></p><h4 id="展示本地仓库关联远程仓库详情"><a href="#展示本地仓库关联远程仓库详情" class="headerlink" title="展示本地仓库关联远程仓库详情:"></a>展示本地仓库关联远程仓库详情:</h4><p><code>git branch -vv</code></p><h4 id="从远程分支创建并切换到本地"><a href="#从远程分支创建并切换到本地" class="headerlink" title="从远程分支创建并切换到本地:"></a>从远程分支创建并切换到本地:</h4><p><code>git chekout -b &lt;分支&gt;&lt;远程仓库&gt;/&lt;分支&gt;</code></p><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p><code>git push origin --delete &lt;remote-分支&gt;</code></p><h4 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h4><p><code>git remote set-url origin &lt;URL&gt;</code></p><h4 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h4><p><code>git ststus --ignored</code></p><h4 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h4><p><code>git push -f &lt;远程仓库&gt;&lt;分支&gt;</code> </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;初始化远程仓库&quot;&gt;&lt;a href=&quot;#初始化远程仓库&quot; class=&quot;headerlink&quot; title=&quot;初始化远程仓库&quot;&gt;&lt;/a&gt;初始化远程仓库&lt;/h2&gt;&lt;h4 id=&quot;克隆版本库&quot;&gt;&lt;a href=&quot;#克隆版本库&quot; class=&quot;headerlink&quot; title=&quot;克隆版本库&quot;&gt;&lt;/a&gt;克隆版本库&lt;/h4&gt;&lt;p&gt;&lt;code&gt;git clone &amp;lt; url &amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加远程版本库的别名&quot;&gt;&lt;a href=&quot;#添加远程版本库的别名&quot; class=&quot;headerlink&quot; title=&quot;添加远程版本库的别名&quot;&gt;&lt;/a&gt;添加远程版本库的别名&lt;/h4&gt;&lt;p&gt;&lt;code&gt;git remote add &amp;lt;别名&amp;gt;&amp;lt; url &amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;删除远程版本库的别名&quot;&gt;&lt;a href=&quot;#删除远程版本库的别名&quot; class=&quot;headerlink&quot; title=&quot;删除远程版本库的别名&quot;&gt;&lt;/a&gt;删除远程版本库的别名&lt;/h4&gt;&lt;p&gt;&lt;code&gt;git remote rm &amp;lt;别名&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建一个无本地分支的库&quot;&gt;&lt;a href=&quot;#创建一个无本地分支的库&quot; class=&quot;headerlink&quot; title=&quot;创建一个无本地分支的库&quot;&gt;&lt;/a&gt;创建一个无本地分支的库&lt;/h4&gt;&lt;p&gt;&lt;code&gt;git init -bare&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>版本控制Git本地常用命令</title>
    <link href="http://example.com/2022/05/20/git%E6%9C%AC%E5%9C%B0%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/20/git%E6%9C%AC%E5%9C%B0%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-20T13:19:31.000Z</published>
    <updated>2022-05-22T06:03:15.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置git身份信息"><a href="#配置git身份信息" class="headerlink" title="配置git身份信息"></a>配置git身份信息</h2><span id="more"></span><h4 id="添加-x2F-修改用户名信息"><a href="#添加-x2F-修改用户名信息" class="headerlink" title="添加&#x2F;修改用户名信息"></a>添加&#x2F;修改用户名信息</h4><p><code>git config --globa user.name &quot;用户名&quot;</code></p><h4 id="添加-x2F-修改用户邮箱"><a href="#添加-x2F-修改用户邮箱" class="headerlink" title="添加&#x2F;修改用户邮箱"></a>添加&#x2F;修改用户邮箱</h4><p><code>git config --globa user.email &quot;邮箱&quot; </code></p><h4 id="查看用户所有信息"><a href="#查看用户所有信息" class="headerlink" title="查看用户所有信息"></a>查看用户所有信息</h4><p><code>git config -l</code></p><h4 id="查看用户名"><a href="#查看用户名" class="headerlink" title="查看用户名"></a>查看用户名</h4><p><code>git config --globa user.name </code></p><h4 id="查看用户邮箱"><a href="#查看用户邮箱" class="headerlink" title="查看用户邮箱"></a>查看用户邮箱</h4><p><code>git config --globa user.email </code></p><h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><p>在本地创建一个文件夹作为仓库,在仓库内运行git bash进入命令行</p><h4 id="git-init初始化仓库"><a href="#git-init初始化仓库" class="headerlink" title="git init初始化仓库"></a><code>git init</code>初始化仓库</h4><p>在仓库里会出现一个.git隐藏文件,在这个文件中包含了该仓库的所有信息</p><h2 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h2><p>本地仓库分为工作区,暂存区,仓库三部分.在工作区完成后需要将修改后的文件放到暂存区,没有问题的话在提交到本地仓库</p><h4 id="查看当前仓库的工作区状态"><a href="#查看当前仓库的工作区状态" class="headerlink" title="查看当前仓库的工作区状态"></a>查看当前仓库的工作区状态</h4><p><code>git status</code></p><h4 id="将工作区的文件添加到暂存区"><a href="#将工作区的文件添加到暂存区" class="headerlink" title="将工作区的文件添加到暂存区"></a>将工作区的文件添加到暂存区</h4><p>添加单个文件: <code>git add &quot;文件&quot;</code><br>添加所有文件: <code>git add .</code><br>添加某一类型文件: <code>git add *.txt</code></p><h4 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h4><p><code>git commit -m &quot;提交说明信息&quot;</code></p><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><p>撤销添加到暂存区: <code>git reset head</code></p><p>撤销提交到仓库: <code>git reset --mixed head^版本 </code><br>    <code>--mixed</code>:不删除代码改动,撤销提交和暂存 .<br><code>--soft</code>:不删除代码改动,不撤销暂存,撤销提交.<br><code>--hard</code>:删除代码改动,撤销提交和暂存 .</p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>分支可以帮助我们在不对原来代码影响的情况下进行操作,操作之后可以再进行合并进行修改</p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支:"></a>创建分支:</h4><p><code>git branch &quot; 分支名称&quot;</code></p><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支:"></a>查看分支:</h4><p>查看本地分支:<code>git branch </code><br>查看所有分支: <code>git branch -a</code></p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支:"></a>切换分支:</h4><p><code>git checkout &#39;分支&#39;</code></p><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支:"></a>合并分支:</h4><p><code>git merge &#39;分支&#39;</code>产生合并冲突时,将冲突部分进行合并即可</p><h4 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支:"></a>重命名分支:</h4><p>不覆盖已存在同名分支:<code>git branch -m &#39;旧&#39;&#39;新&#39;</code><br>覆盖已存在同名分支:<code>git branch -M &#39;旧&#39;&#39;新&#39;</code></p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支:"></a>删除分支:</h4><p>没有合并不会删除: <code>git branch -d &quot;分支名称&quot;</code><br>强制删除: <code>git branch -D &quot;分支名称&quot;</code></p><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><h4 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态:"></a>查看当前状态:</h4><p><code>git status</code></p><h4 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录:"></a>查看历史记录:</h4><p><code>git log</code><br>查看分支历史记录: <code>gitk &lt;分支&gt;</code></p><h4 id="每个分支最后的提交"><a href="#每个分支最后的提交" class="headerlink" title="每个分支最后的提交:"></a>每个分支最后的提交:</h4><p><code>git branch -v</code></p><h2 id="下一篇文章分享git的远程仓库"><a href="#下一篇文章分享git的远程仓库" class="headerlink" title="下一篇文章分享git的远程仓库"></a>下一篇文章分享git的远程仓库</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;配置git身份信息&quot;&gt;&lt;a href=&quot;#配置git身份信息&quot; class=&quot;headerlink&quot; title=&quot;配置git身份信息&quot;&gt;&lt;/a&gt;配置git身份信息&lt;/h2&gt;</summary>
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
</feed>
